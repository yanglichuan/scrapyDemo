Python 3 教程

 Python 3 教程 
 Python 的 3.0 版本，常被称为 Python 3000，或简称 Py3k。相对于 Python 的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python 3.0 在设计的时候没有考虑向下兼容。 Python 介绍及安装教程我们在 Python 2.X 版本的教程 中已有介绍，这里就不再赘述。 你也可以点击 Python2.x与3​​.x版本区别 来查看两者的不同。 本教程主要针对 Python 3.x 版本的学习，如果你使用的是 Python 2.x 版本请移步至 Python 2.X 版本的教程 官方宣布，2020 年 1 月 1 日， 停止 Python 2 的更新。 
 查看 Python 版本 
 我们可以在命令窗口(Windows 使用 win+R 调出 cmd 运行框)使用以下命令查看我们使用的 Python 版本： 以上命令执行结果如下： 你也可以进入Python的交互式编程模式，查看版本： 
 第一个Python3.x程序 
 对于大多数程序语言，第一个入门编程代码便是"Hello World！"，以下代码为使用Python输出"Hello World！"： 实例(Python 3.0+) #!/usr/bin/python3 print ( " Hello, World! " ) 运行实例 » 你可以将以上代码保存在 hello.py 文件中并使用 python 命令执行该脚本文件。 以上命令输出结果为： 
 相关内容： 
  Python 3.6.3 中文手册 Python 2.X 版本的教程
	Python3 MySQL 数据库连接 - PyMySQL 驱动

 Python3 MySQL 数据库连接 - PyMySQL 驱动 
 本文我们为大家介绍 Python3 使用 PyMySQL 连接数据库，并实现简单的增删改查。 
 什么是 PyMySQL？ 
 PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。 PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 
 PyMySQL 安装 
 在使用 PyMySQL 之前，我们需要确保 PyMySQL 已安装。 PyMySQL 下载地址：https://github.com/PyMySQL/PyMySQL。 如果还未安装，我们可以使用以下命令安装最新版的 PyMySQL： 如果你的系统不支持 pip 命令，可以使用以下方式安装： 1、使用 git 命令下载安装包安装(你也可以手动下载)： 2、如果需要制定版本号，可以使用 curl 命令来安装： 注意： 请确保您有root权限来安装上述模块。 安装的过程中可能会出现"ImportError: No module named setuptools"的错误提示，意思是你没有安装setuptools，你可以访问 https://pypi.python.org/pypi/setuptools Linux 系统安装实例： 
 数据库连接 
 连接数据库前，请先确认以下事项： 您已经创建了数据库 TESTDB. 在TESTDB数据库中您已经创建了表 EMPLOYEE EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。 连接数据库TESTDB使用的用户名为 "testuser" ，密码为 "test123",你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令。 在你的机子上已经安装了 Python  MySQLdb 模块。 如果您对sql语句不熟悉，可以访问我们的 SQL基础教程 
 实例： 
 以下实例链接 Mysql 的 TESTDB 数据库： 实例(Python 3.0+) #!/usr/bin/python3 import  pymysql # 打开数据库连接 db = pymysql . connect ( " localhost " , " testuser " , " test123 " , " TESTDB "  ) # 使用 cursor() 方法创建一个游标对象 cursor cursor = db . cursor ( ) # 使用 execute()  方法执行 SQL 查询 cursor . execute ( " SELECT VERSION() " ) # 使用 fetchone() 方法获取单条数据. data = cursor . fetchone ( ) print  ( " Database version : %s " % data ) # 关闭数据库连接 db . close ( ) 执行以上脚本输出结果如下： 实例(Python 3.0+) #!/usr/bin/python3 import  pymysql # 打开数据库连接 db = pymysql . connect ( " localhost " , " testuser " , " test123 " , " TESTDB "  ) # 使用 cursor() 方法创建一个游标对象 cursor cursor = db . cursor ( ) # 使用 execute() 方法执行 SQL，如果表存在则删除 cursor . execute ( " DROP TABLE IF EXISTS EMPLOYEE " ) # 使用预处理语句创建表 sql = """ """ cursor . execute ( sql ) # 关闭数据库连接 db . close ( ) 
 数据库插入操作 
 实例(Python 3.0+) #!/usr/bin/python3 import  pymysql # 打开数据库连接 db = pymysql . connect ( " localhost " , " testuser " , " test123 " , " TESTDB "  ) # 使用cursor()方法获取操作游标 cursor = db . cursor ( ) # SQL 插入语句 sql = """ """ try # 执行sql语句 cursor . execute ( sql ) # 提交到数据库执行 db . commit ( ) except # 如果发生错误则回滚 db . rollback ( ) # 关闭数据库连接 db . close ( ) 以上例子也可以写成如下形式： 实例(Python 3.0+) #!/usr/bin/python3 import  pymysql # 打开数据库连接 db = pymysql . connect ( " localhost " , " testuser " , " test123 " , " TESTDB "  ) # 使用cursor()方法获取操作游标 cursor = db . cursor ( ) # SQL 插入语句 sql = " " ( ' Mac ' , ' Mohan ' , 20 , ' M ' , 2000 ) try # 执行sql语句 cursor . execute ( sql ) # 执行sql语句 db . commit ( ) except # 发生错误时回滚 db . rollback ( ) # 关闭数据库连接 db . close ( ) 以下代码使用变量向SQL语句中传递参数: 
 数据库查询操作 
 Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。  fetchone(): 该方法获取下一个查询结果集。结果集是一个对象  fetchall(): 接收全部的返回结果行.  rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。  
 实例： 
 查询EMPLOYEE表中salary（工资）字段大于1000的所有数据： 实例(Python 3.0+) #!/usr/bin/python3 import  pymysql # 打开数据库连接 db = pymysql . connect ( " localhost " , " testuser " , " test123 " , " TESTDB "  ) # 使用cursor()方法获取操作游标 cursor = db . cursor ( ) # SQL 查询语句 sql = " " % ( 1000 ) try # 执行SQL语句 cursor . execute ( sql ) # 获取所有记录列表 results = cursor . fetchall ( ) for  row  in  results fname = row [ 0 ] lname = row [ 1 ] age = row [ 2 ] sex = row [ 3 ] income = row [ 4 ] # 打印结果 print  ( " fname=%s,lname=%s,age=%s,sex=%s,income=%s " ( fname , lname , age , sex , income  ) ) except print  ( " Error: unable to fetch data " ) # 关闭数据库连接 db . close ( ) 以上脚本执行结果如下： 
 数据库更新操作 
 更新操作用于更新数据表的的数据，以下实例将 TESTDB 表中 SEX 为 'M' 的 AGE 字段递增 1： 实例(Python 3.0+) #!/usr/bin/python3 import  pymysql # 打开数据库连接 db = pymysql . connect ( " localhost " , " testuser " , " test123 " , " TESTDB "  ) # 使用cursor()方法获取操作游标 cursor = db . cursor ( ) # SQL 更新语句 sql = " UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c' " % ( ' M ' ) try # 执行SQL语句 cursor . execute ( sql ) # 提交到数据库执行 db . commit ( ) except # 发生错误时回滚 db . rollback ( ) # 关闭数据库连接 db . close ( ) 
 删除操作 
 删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据： 实例(Python 3.0+) #!/usr/bin/python3 import  pymysql # 打开数据库连接 db = pymysql . connect ( " localhost " , " testuser " , " test123 " , " TESTDB "  ) # 使用cursor()方法获取操作游标 cursor = db . cursor ( ) # SQL 删除语句 sql = " DELETE FROM EMPLOYEE WHERE AGE > %s " % ( 20 ) try # 执行SQL语句 cursor . execute ( sql ) # 提交修改 db . commit ( ) except # 发生错误时回滚 db . rollback ( ) # 关闭连接 db . close ( ) 
 执行事务 
 事务机制可以确保数据一致性。 事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。  原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。 
 实例 
 实例(Python 3.0+) # SQL删除记录语句 sql = " DELETE FROM EMPLOYEE WHERE AGE > %s " % ( 20 ) try # 执行SQL语句 cursor . execute ( sql ) # 向数据库提交 db . commit ( ) except # 发生错误时回滚 db . rollback ( ) 对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。 commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。 
 错误处理 
 DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常:   异常 描述   Warning 当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。  Error 警告以外所有其他错误类。必须是 StandardError 的子类。  InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。  DatabaseError 和数据库有关的错误发生时触发。 必须是Error的子类。  DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。  OperationalError 指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。  IntegrityError 完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。  InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。  ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。  NotSupportedError 不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。 
	Python CGI编程

 Python CGI编程 
 
 什么是CGI 
 CGI 目前由NCSA维护，NCSA定义CGI如下： 
 网页浏览 
 为了更好的了解CGI是如何工作的，我们可以从在网页上点击一个链接或URL的流程： CGI程序可以是Python脚本，PERL脚本，SHELL脚本，C或者C++程序等。 
 Web服务器支持及配置 
 在你进行CGI编程前，确保您的Web服务器支持CGI及已经配置了CGI的处理程序。 Apache 支持CGI 配置： 设置好CGI目录： 在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件： 
 第一个CGI程序 
 我们使用Python创建第一个CGI程序，文件名为hello.py，文件位于/var/www/cgi-bin目录中，内容如下： 文件保存后修改 hello.py，修改文件权限为 755： chmod 755 hello.py 以上程序在浏览器访问显示结果如下： 这个的hello.py脚本是一个简单的Python脚本，脚本第一行的输出内容"Content-type:text/html"发送到浏览器并告知浏览器显示的内容类型为"text/html"。 用 print 输出一个空行用于告诉服务器结束头部信息。 
 HTTP头部 
 hello.py文件内容中的" Content-type:text/html"即为HTTP头部的一部分，它会发送给浏览器告诉浏览器文件的内容类型。 HTTP头部的格式如下： 以下表格介绍了CGI程序中HTTP头部经常使用的信息： 头 描述  Content-type: 请求的与实体对应的MIME信息。例如: Content-type:text/html  Expires: Date 响应过期的日期和时间   Location: URL 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源   Last-modified: Date 请求资源的最后修改时间   Content-length: N 请求的内容长度   Set-Cookie: String 设置Http Cookie  
 CGI环境变量 
 所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用： 变量名 描述  CONTENT_TYPE 这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。   CONTENT_LENGTH 如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。   HTTP_COOKIE 客户机内的 COOKIE 内容。   HTTP_USER_AGENT 提供包含了版本数或其他专有数据的客户浏览器信息。   PATH_INFO 这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。   QUERY_STRING 如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号'?'分隔。   REMOTE_ADDR 这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。   REMOTE_HOST 这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。   REQUEST_METHOD 提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。  SCRIPT_FILENAME CGI脚本的完整路径  SCRIPT_NAME CGI脚本的的名称  SERVER_NAME 这是你的 WEB 服务器的主机名、别名或IP地址。  SERVER_SOFTWARE 这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix) 以下是一个简单的CGI脚本输出CGI的环境变量： 将以上点保存为 test.py ,并修改文件权限为 755，执行结果如下： 
 GET和POST方法 
 浏览器客户端通过两种方法向服务器传递信息，这两种方法就是 GET 方法和 POST 方法。 
 使用GET方法传输数据 
 GET方法发送编码后的用户信息到服务端，数据信息包含在请求页面的URL上，以"?"号分割, 如下所示： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 
 简单的url实例：GET方法 
 以下是一个简单的URL，使用GET方法向hello_get.py程序发送两个参数： 以下为hello_get.py文件的代码： 文件保存后修改 hello_get.py，修改文件权限为 755： chmod 755 hello_get.py 浏览器请求输出结果： 
 简单的表单实例：GET方法 
 以下是一个通过HTML的表单使用GET方法向服务器发送两个数据，提交的服务器脚本同样是hello_get.py文件，hello_get.html 代码如下： 默认情况下 cgi-bin 目录只能存放脚本文件，我们将 hello_get.html 存储在 test 目录下，修改文件权限为 755： Gif 演示如下所示： 
 使用POST方法传递数据 
 使用POST方法向服务器传递数据是更安全可靠的，像一些敏感信息如用户密码等需要使用POST传输数据。 以下同样是hello_get.py ，它也可以处理浏览器提交的POST表单数据: 以下为表单通过POST方法（ method="post" ）向服务器脚本 hello_get.py 提交数据: Gif 演示如下所示： 
 通过CGI程序传递checkbox数据 
 checkbox用于提交一个或者多个选项数据，HTML代码如下： 以下为 checkbox.py 文件的代码： 修改 checkbox.py 权限： 浏览器访问 Gif 演示图： 
 通过CGI程序传递Radio数据 
 Radio 只向服务器传递一个数据，HTML代码如下： radiobutton.py 脚本代码如下： 修改 radiobutton.py 权限： 浏览器访问 Gif 演示图： 
 通过CGI程序传递 Textarea 数据 
 Textarea 向服务器传递多行数据，HTML代码如下： textarea.py 脚本代码如下： 修改 textarea.py 权限： 浏览器访问 Gif 演示图： 
 通过CGI程序传递下拉数据。 
 HTML 下拉框代码如下： dropdown.py 脚本代码如下所示： 修改 dropdown.py 权限： 浏览器访问 Gif 演示图： 
 CGI中使用Cookie 
 
 cookie的语法 
 http cookie的发送是通过http头部来实现的，他早于文件的传递，头部set-cookie的语法如下： name=name: 需要设置cookie的值(name不能使用" ; "和" , "号),有多个name值时用 " ; " 分隔，例如： name1=name1;name2=name2;name3=name3 。  expires=date: cookie的有效期限,格式： expires="Wdy,DD-Mon-YYYY HH:MM:SS"   path=path:  domain=domain:  secure:  cookie的接收是通过设置环境变量HTTP_COOKIE来实现的，CGI程序可以通过检索该变量获取cookie信息。 
 Cookie设置 
 Cookie的设置非常简单，cookie会在http头部单独发送。以下实例在cookie中设置了name 和 expires： 将以上代码保存到 cookie_set.py，并修改 cookie_set.py 权限： 以下是一个简单的CGI检索cookie信息的程序： 将以上代码保存到 cookie_get.py，并修改 cookie_get.py 权限： 以上 cookie 设置颜色 Gif 如下所示： 
 文件上传实例 
 HTML设置上传文件的表单需要设置 enctype 属性为 multipart/form-data ，代码如下所示： save_file.py脚本文件代码如下： 将以上代码保存到 save_file.py，并修改 save_file.py 权限： 以上 cookie 设置颜色 Gif 如下所示： 如果你使用的系统是Unix/Linux，你必须替换文件分隔符，在window下只需要使用open()语句即可： 
 文件下载对话框 
 我们先在当前目录下创建 foo.txt 文件，用于程序的下载。 文件下载通过设置HTTP头信息来实现，功能代码如下：
	Python3 XML 解析

 Python3 XML 解析 
 
 什么是 XML？ 
 XML 指可扩展标记语言（e X tensible M arkup L XML 教程 XML 被设计用来传输和存储数据。 XML 是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。 它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。 
 Python 对 XML 的解析 
 常见的 XML 编程接口有 DOM 和 SAX，这两种接口处理 XML 文件的方式不同，当然使用场合也不同。 Python 有三种方法解析 XML，SAX，DOM，以及 ElementTree: 
 1.SAX (simple API for XML ) 
 Python 标准库包含 SAX 解析器，SAX 用事件驱动模型，通过在解析 XML 的过程中触发一个个的事件并调用用户定义的回调函数来处理 XML 文件。 
 2.DOM(Document Object Model) 
 将 XML 数据在内存中解析成一个树，通过对树的操作来操作 XML。 本章节使用到的 XML 实例文件 movies.xml 内容如下： 
 Python 使用 SAX 解析 xml 
 SAX 是一种基于事件驱动的API。 利用 SAX 解析 XML 文档牵涉到两个部分: 解析器 和 事件处理器 。 解析器负责读取 XML 文档，并向事件处理器发送事件，如元素开始跟元素结束事件。 在 Python 中使用 sax 方式处理 xml 要先引入 xml.sax 中的 parse 函数，还有 xml.sax.handler 中的 ContentHandler。 ContentHandler 类方法介绍 characters(content) 方法 调用时机： 从行开始，遇到标签之前，存在字符，content 的值为这些字符串。 从一个标签，遇到下一个标签之前， 存在字符，content 的值为这些字符串。 从一个标签，遇到行结束符之前，存在字符，content 的值为这些字符串。 标签可以是开始标签，也可以是结束标签。 startDocument() 方法 文档启动的时候调用。 endDocument() 方法 解析器到达文档结尾时调用。 startElement(name, attrs) 方法 遇到XML开始标签时调用，name 是标签的名字，attrs 是标签的属性值字典。 endElement(name) 方法 遇到XML结束标签时调用。 make_parser 方法 以下方法创建一个新的解析器对象并返回。 参数说明: parser_list parser 方法 以下方法创建一个 SAX 解析器并解析xml文档： 参数说明: xmlfile contenthandler errorhandler parseString 方法 parseString 方法创建一个 XML 解析器并解析 xml 字符串： 参数说明: xmlstring contenthandler errorhandler Python 解析XML实例 以上代码执行结果如下： 完整的 SAX API 文档请查阅 Python SAX APIs 使用xml.dom解析xml 文件对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。 python中用xml.dom.minidom来解析xml文件，实例如下： 以上程序执行结果如下： 完整的  DOM API 文档请查阅 Python DOM APIs 。
	Python3 JSON 数据解析

 Python3 JSON 数据解析 
 JSON (JavaScript Object Notation)  是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数： json.dumps(): 对数据进行编码。 json.loads(): 对数据进行解码。 
 Python 编码为 JSON 类型转换对应表： 
 Python JSON dict object list, tuple array str string int, float, int- & float-derived Enums number True true False false None null 
 JSON 解码为 Python 类型转换对应表： 
 JSON Python object dict array list string str number (int) int number (real) float true True false False null None 
 json.dumps 与 json.loads 实例 
 以下实例演示了 Python 数据结构转换为JSON： 实例(Python 3.0+) #!/usr/bin/python3 import  json # Python 字典类型转换为 JSON 对象 data ' no ' : 1 ' name ' : ' Runoob ' ' url ' : ' http://www.runoob.com ' json_str = json . dumps ( data ) print  ( " Python 原始数据： " , repr ( data ) ) print  ( " JSON 对象： " , json_str ) 执行以上代码输出结果为： 通过输出的结果可以看出，简单类型通过编码后跟其原始的repr()输出结果非常相似。 接着以上实例，我们可以将一个JSON编码的字符串转换回一个Python数据结构： 实例(Python 3.0+) #!/usr/bin/python3 import  json # Python 字典类型转换为 JSON 对象 data1 ' no ' : 1 ' name ' : ' Runoob ' ' url ' : ' http://www.runoob.com ' json_str = json . dumps ( data1 ) print  ( " Python 原始数据： " , repr ( data1 ) ) print  ( " JSON 对象： " , json_str ) # 将 JSON 对象转换为 Python 字典 data2 = json . loads ( json_str ) print  ( " data2['name']: " , data2 [ ' name ' ] ) print  ( " data2['url']: " , data2 [ ' url ' ] ) 执行以上代码输出结果为： 如果你要处理的是文件而不是字符串，你可以使用 json.dump() 和 json.load() 来编码和解码JSON数据。例如： 实例(Python 3.0+) # 写入 JSON 数据 with  open ( ' data.json ' , ' w ' )  as  f json . dump ( data , f ) # 读取数据 with  open ( ' data.json ' , ' r ' )  as  f data = json . load ( f ) 更多资料请参考： https://docs.python.org/3/library/json.html
	Python3 SMTP发送邮件

 Python3 SMTP发送邮件 
 SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。 Python创建 SMTP 对象语法如下： 参数说明： Python SMTP对象使用sendmail方法发送邮件，语法如下： 参数说明： 这里要注意一下第三个参数，msg是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意msg的格式。这个格式就是smtp协议中定义的格式。 
 实例 
 以下是一个使用Python发送邮件简单的实例： 
 实例 
 #!/usr/bin/python3 import  smtplib from  email . mime . text  import  MIMEText from  email . header  import  Header sender = ' from@runoob.com ' receivers = [ ' 429240967@qq.com ' ]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码 message = MIMEText ( ' Python 邮件发送测试... ' , ' plain ' , ' utf-8 ' ) message [ ' From ' ] = Header ( " 菜鸟教程 " , ' utf-8 ' )  # 发送者 message [ ' To ' ] = Header ( " 测试 " , ' utf-8 ' )  # 接收者 subject = ' Python SMTP 邮件测试 ' message [ ' Subject ' ] = Header ( subject , ' utf-8 ' ) try smtpObj = smtplib . SMTP ( ' localhost ' ) smtpObj . sendmail ( sender , receivers , message . as_string ( ) ) print  ( " 邮件发送成功 " ) except  smtplib . SMTPException print  ( " Error: 无法发送邮件 " ) 我们使用三个引号来设置邮件信息，标准邮件需要三个头部信息： From , To , 和 Subject ，每个信息直接使用空行分割。 我们通过实例化 smtplib 模块的 SMTP 对象 smtpObj 来连接到 SMTP 访问，并使用 sendmail 方法来发送信息。 执行以上程序，如果你本机安装sendmail，就会输出： 查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息： 如果我们本机没有 sendmail 访问，也可以使用其他服务商的 SMTP 访问（QQ、网易、Google等）。 
 实例 
 #!/usr/bin/python3 import  smtplib from  email . mime . text  import  MIMEText from  email . header  import  Header # 第三方 SMTP 服务 mail_host = " smtp.XXX.com "  #设置服务器 mail_user = " XXXX "  #用户名 mail_pass = " XXXXXX "  #口令 sender = ' from@runoob.com ' receivers = [ ' 429240967@qq.com ' ]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 message = MIMEText ( ' Python 邮件发送测试... ' , ' plain ' , ' utf-8 ' ) message [ ' From ' ] = Header ( " 菜鸟教程 " , ' utf-8 ' ) message [ ' To ' ] = Header ( " 测试 " , ' utf-8 ' ) subject = ' Python SMTP 邮件测试 ' message [ ' Subject ' ] = Header ( subject , ' utf-8 ' ) try smtpObj = smtplib . SMTP ( ) smtpObj . connect ( mail_host , 25 )  # 25 为 SMTP 端口号 smtpObj . login ( mail_user , mail_pass ) smtpObj . sendmail ( sender , receivers , message . as_string ( ) ) print  ( " 邮件发送成功 " ) except  smtplib . SMTPException print  ( " Error: 无法发送邮件 " ) 
 使用Python发送HTML格式的邮件 
 Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下： 
 实例 
 #!/usr/bin/python3 import  smtplib from  email . mime . text  import  MIMEText from  email . header  import  Header sender = ' from@runoob.com ' receivers = [ ' 429240967@qq.com ' ]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 mail_msg = """ """ message = MIMEText ( mail_msg , ' html ' , ' utf-8 ' ) message [ ' From ' ] = Header ( " 菜鸟教程 " , ' utf-8 ' ) message [ ' To ' ] = Header ( " 测试 " , ' utf-8 ' ) subject = ' Python SMTP 邮件测试 ' message [ ' Subject ' ] = Header ( subject , ' utf-8 ' ) try smtpObj = smtplib . SMTP ( ' localhost ' ) smtpObj . sendmail ( sender , receivers , message . as_string ( ) ) print  ( " 邮件发送成功 " ) except  smtplib . SMTPException print  ( " Error: 无法发送邮件 " ) 执行以上程序，如果你本机安装sendmail，就会输出： 查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息： 
 Python 发送带附件的邮件 
 发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 
 实例 
 #!/usr/bin/python3 import  smtplib from  email . mime . text  import  MIMEText from  email . mime . multipart  import  MIMEMultipart from  email . header  import  Header sender = ' from@runoob.com ' receivers = [ ' 429240967@qq.com ' ]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例 message = MIMEMultipart ( ) message [ ' From ' ] = Header ( " 菜鸟教程 " , ' utf-8 ' ) message [ ' To ' ] = Header ( " 测试 " , ' utf-8 ' ) subject = ' Python SMTP 邮件测试 ' message [ ' Subject ' ] = Header ( subject , ' utf-8 ' ) #邮件正文内容 message . attach ( MIMEText ( ' 这是菜鸟教程Python 邮件发送测试…… ' , ' plain ' , ' utf-8 ' ) ) # 构造附件1，传送当前目录下的 test.txt 文件 att1 = MIMEText ( open ( ' test.txt ' , ' rb ' ) . read ( ) , ' base64 ' , ' utf-8 ' ) att1 [ " Content-Type " ] = ' application/octet-stream ' # 这里的filename可以任意写，写什么名字，邮件中显示什么名字 att1 [ " Content-Disposition " ] = ' attachment; filename="test.txt" ' message . attach ( att1 ) # 构造附件2，传送当前目录下的 runoob.txt 文件 att2 = MIMEText ( open ( ' runoob.txt ' , ' rb ' ) . read ( ) , ' base64 ' , ' utf-8 ' ) att2 [ " Content-Type " ] = ' application/octet-stream ' att2 [ " Content-Disposition " ] = ' attachment; filename="runoob.txt" ' message . attach ( att2 ) try smtpObj = smtplib . SMTP ( ' localhost ' ) smtpObj . sendmail ( sender , receivers , message . as_string ( ) ) print  ( " 邮件发送成功 " ) except  smtplib . SMTPException print  ( " Error: 无法发送邮件 " ) 查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息： 
 在 HTML 文本中添加图片 
 邮件的 HTML 文本中一般邮件服务商添加外链是无效的，正确添加图片的实例如下所示： 
 实例 
 #!/usr/bin/python3 import  smtplib from  email . mime . image  import  MIMEImage from  email . mime . multipart  import  MIMEMultipart from  email . mime . text  import  MIMEText from  email . header  import  Header sender = ' from@runoob.com ' receivers = [ ' 429240967@qq.com ' ]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 msgRoot = MIMEMultipart ( ' related ' ) msgRoot [ ' From ' ] = Header ( " 菜鸟教程 " , ' utf-8 ' ) msgRoot [ ' To ' ] = Header ( " 测试 " , ' utf-8 ' ) subject = ' Python SMTP 邮件测试 ' msgRoot [ ' Subject ' ] = Header ( subject , ' utf-8 ' ) msgAlternative = MIMEMultipart ( ' alternative ' ) msgRoot . attach ( msgAlternative ) mail_msg = """ """ msgAlternative . attach ( MIMEText ( mail_msg , ' html ' , ' utf-8 ' ) ) # 指定图片为当前目录 fp = open ( ' test.png ' , ' rb ' ) msgImage = MIMEImage ( fp . read ( ) ) fp . close ( ) # 定义图片 ID，在 HTML 文本中引用 msgImage . add_header ( ' Content-ID ' , ' <image1> ' ) msgRoot . attach ( msgImage ) try smtpObj = smtplib . SMTP ( ' localhost ' ) smtpObj . sendmail ( sender , receivers , msgRoot . as_string ( ) ) print  ( " 邮件发送成功 " ) except  smtplib . SMTPException print  ( " Error: 无法发送邮件 " ) 查看我们的收件箱(如果在垃圾箱可能需要移动到收件箱才可正常显示)，就可以查看到邮件信息： 
 使用第三方 SMTP 服务发送 
 这里使用了 QQ 邮箱(你也可以使用 163，Gmail等)的 SMTP 服务，需要做以下配置： QQ 邮箱通过生成授权码来设置密码： QQ 邮箱 SMTP 服务器地址：smtp.qq.com，ssl 端口：465。 以下实例你需要修改：发件人邮箱（你的QQ邮箱），密码，收件人邮箱（可发给自己）。 QQ SMTP #!/usr/bin/python3 import  smtplib from  email . mime . text  import  MIMEText from  email . utils  import  formataddr my_sender = ' 429240967@qq.com '  # 发件人邮箱账号 my_pass = ' xxxxxxxxxx '  # 发件人邮箱密码 my_user = ' 429240967@qq.com '  # 收件人邮箱账号，我这边发送给自己 def  mail ( ) ret = True try msg = MIMEText ( ' 填写邮件内容 ' , ' plain ' , ' utf-8 ' ) msg [ ' From ' ] = formataddr ( [ " FromRunoob " , my_sender ] )  # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg [ ' To ' ] = formataddr ( [ " FK " , my_user ] )  # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg [ ' Subject ' ] = " 菜鸟教程发送邮件测试 "  # 邮件的主题，也可以说是标题 server = smtplib . SMTP_SSL ( " smtp.qq.com " , 465 )  # 发件人邮箱中的SMTP服务器，端口是25 server . login ( my_sender , my_pass )  # 括号中对应的是发件人邮箱账号、邮箱密码 server . sendmail ( my_sender , [ my_user , ] , msg . as_string ( ) )  # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server . quit ( )  # 关闭连接 except  Exception : # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret = False return  ret ret = mail ( ) if  ret print ( " 邮件发送成功 " ) else print ( " 邮件发送失败 " ) 发送成功后，登陆收件人邮箱即可查看： 更多内容请参阅： https://docs.python.org/3/library/email-examples.html 。
	Python3 内置函数

 Python3 内置函数 
 注意： 有些函数与 Python2.x 变化不大，会直接跳转到 Python2.x 教程下的内置函数说明，大家要注意下哈。 内置函数 abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round()  delattr() hash() memoryview() set() 
	Python3  日期和时间
Python3 日期和时间 Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。 Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。 时间间隔是以秒为单位的浮点小数。 每个时间戳都以自从 1970 年 1 月 1 日午夜（历元）经过了多长时间来表示。 Python 的 time 模块下有很多函数可以转换常见日期格式。如函数 time.time() 用于获取当前时间戳, 如下实例: 实例  #!/usr/bin/python3 import  time  # 引入time模块 =  time . time ( ) print  ( "当前时间戳为:" , ticks ) 以上实例输出结果： 
 什么是时间元组？ 
 很多Python函数用一个元组装起来的9组数字处理时间: 字段 值 0 4位数年 2008 1 月 1 到 12 2 日 1到31 3 小时 0到23 4 分钟 0到59 5 秒 0到61 (60或61 是闰秒) 6 一周的第几日 0到6 (0是周一) 7 一年的第几日 1到366 (儒略历) 8 夏令时 -1, 0, 1, -1是决定是否为夏令时的旗帜 上述也就是struct_time元组。这种结构具有如下属性： 序号 属性 值 0 tm_year 2008 1 tm_mon 1 到 12 2 tm_mday 1 到 31 3 tm_hour 0 到 23 4 tm_min 0 到 59 5 tm_sec 0 到 61 (60或61 是闰秒) 6 tm_wday 0到6 (0是周一) 7 tm_yday 一年中的第几天，1 到 366 8 tm_isdst 是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1 
 获取当前时间 
 从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。 以上实例输出结果： 
 获取格式化的时间 
 你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime(): 以上实例输出结果： 
 格式化日期 
 我们可以使用 time 模块的 strftime 方法来格式化日期，： 以上实例输出结果： python中时间日期格式化符号：  %y 两位数的年份表示（00-99）  %Y 四位数的年份表示（000-9999）  %m 月份（01-12）  %d 月内中的一天（0-31）  %H 24小时制小时数（0-23）  %I 12小时制小时数（01-12）  %M 分钟数（00=59）  %S 秒（00-59）  %a 本地简化星期名称  %A 本地完整星期名称  %b 本地简化的月份名称  %B 本地完整的月份名称  %c 本地相应的日期表示和时间表示  %j 年内的一天（001-366）  %p 本地A.M.或P.M.的等价符  %U 一年中的星期数（00-53）星期天为星期的开始  %w 星期（0-6），星期天为星期的开始  %W 一年中的星期数（00-53）星期一为星期的开始  %x 本地相应的日期表示  %X 本地相应的时间表示  %Z 当前时区的名称  %% %号本身  
 获取某月日历 
 Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历： 以上实例输出结果： 
 Time 模块 
 Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的： 序号 函数及描述 实例 1 time.altzone 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 以下实例展示了 altzone()函数的使用方法： 2 time.asctime([tupletime]) 接受时间元组并返回一个可读的形式为"Tue Dec 11 18:07:14 2008"（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 以下实例展示了 asctime()函数的使用方法： 3 time.clock() 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 实例 由于该方法依赖操作系统，在 Python 3.3 以后不被推荐，而在 3.8 版本中被移除，需使用下列两个函数替代。 4 time.ctime([secs]) 作用相当于asctime(localtime(secs))，未给参数相当于asctime() 以下实例展示了 ctime()函数的使用方法： 5 time.gmtime([secs]) 接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 以下实例展示了 gmtime()函数的使用方法： 6 time.localtime([secs] 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 以下实例展示了 localtime()函数的使用方法： 7 time.mktime(tupletime) 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 实例 8 time.sleep(secs) 推迟调用线程的运行，secs指秒数。 以下实例展示了 sleep()函数的使用方法： 9 time.strftime(fmt[,tupletime]) 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 以下实例展示了 strftime()函数的使用方法： 10 time.strptime(str,fmt='%a %b %d %H:%M:%S %Y') 根据fmt的格式把一个时间字符串解析为时间元组。 以下实例展示了 strptime()函数的使用方法： 11 time.time( ) 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 以下实例展示了 time()函数的使用方法： 12 time.tzset() 根据环境变量TZ重新初始化时间相关设置。 实例 13 实例 14 Time模块包含了以下2个非常重要的属性： 序号 属性及描述 1 time.timezone 属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（>0，美洲;<=0大部分欧洲，亚洲，非洲）。 2 time.tzname 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。 
 日历（Calendar）模块 
 此模块的函数都是日历相关的，例如打印某月的字符月历。 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数： 序号 函数及描述 1 calendar.calendar(year,w=2,l=1,c=6) 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 2 calendar.firstweekday( ) 返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 3 calendar.isleap(year) 是闰年返回 True，否则为 false。 4 calendar.leapdays(y1,y2) 返回在Y1，Y2两年之间的闰年总数。 5 calendar.month(year,month,w=2,l=1) 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 6 calendar.monthcalendar(year,month) 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 7 calendar.monthrange(year,month) 返回两个整数。第一个是该月的星期几，第二个是该月有几天。星期几是从0（星期一）到 6（星期日）。 (5, 30)解释：5 表示 2014 年 11 月份的第一天是周六，30 表示 2014 年 11 月份总共有 30 天。 8 calendar.prcal(year,w=2,l=1,c=6) 相当于 print calendar.calendar(year,w,l,c). 9 calendar.prmonth(year,month,w=2,l=1) 相当于 print calendar.calendar（year，w，l，c）。 10 calendar.setfirstweekday(weekday) 设置每周的起始日期码。0（星期一）到6（星期日）。 11 calendar.timegm(tupletime) 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 12 calendar.weekday(year,month,day) 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 
 其他相关模块和函数 
 在Python中，其他处理日期和时间的模块还有： time 模块 datetime模块
	Python3 标准库概览

 Python3 标准库概览 
 
 操作系统接口 
 os模块提供了不少与操作系统相关联的函数。 在使用 os 这样的大型模块时内置的 dir() 和 help() 函数非常有用: 针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口: 
 文件通配符 
 
 命令行参数 
 
 错误输出重定向和程序终止 
 sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。 大多脚本的定向终止都使用 "sys.exit()"。 
 字符串正则匹配 
 
 数学 
 random提供了生成随机数的工具。 注意第二个例子需要本地有一个在运行的邮件服务器。 
 日期和时间 
 datetime模块为日期和时间处理同时提供了简单和复杂的方法。 
 数据压缩 
 以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。 
 性能度量 
 有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。 例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多,timeit 证明了现代的方法更快一些。 相对于 timeit 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。 
 测试模块 

	Python3 实例

 Python3 实例 
 以下实例在 Python3.4.3 版本下测试通过： Python Hello World 实例 Python 数字求和 Python 平方根 Python 二次方程 Python 计算三角形的面积 Python 计算圆的面积 Python 随机数生成 Python 摄氏温度转华氏温度 Python 交换变量 Python if 语句 Python 判断字符串是否为数字 Python 判断奇数偶数 Python 判断闰年 Python 获取最大值函数 Python 质数判断 Python 输出指定范围内的素数 Python 阶乘实例 Python 九九乘法表 Python 斐波那契数列 Python 阿姆斯特朗数 Python 十进制转二进制、八进制、十六进制 Python ASCII码与字符相互转换 Python 最大公约数算法 Python 最小公倍数算法 Python 简单计算器实现 Python 生成日历 Python 使用递归斐波那契数列 Python 文件 IO Python 字符串判断 Python 字符串大小写转换 Python 计算每个月天数 Python 获取昨天日期 Python list 常用操作 Python 约瑟夫生者死者小游戏 Python 五人分鱼 Python 实现秒表功能 Python 计算 n 个自然数的立方和 Python 计算数组元素之和 Python 数组翻转指定个数的元素 Python 将列表中的头尾两个元素对调 Python 将列表中的指定位置的两个元素对调 Python 翻转列表 Python 判断元素是否在列表中存在 Python 清空列表 Python 复制列表 Python 计算元素在列表中出现的次数 Python 计算列表元素之和 Python 计算列表元素之积 Python 查找列表中最小元素 Python 查找列表中最大元素 Python 移除字符串中的指定位置字符 Python 判断字符串是否存在子字符串 Python 判断字符串长度 Python 使用正则表达式提取字符串中的 URL Python 将字符串作为代码执行 Python 字符串翻转 Python 对字符串切片及翻转 Python 按键(key)或值(value)对字典进行排序 Python 计算字典值之和 Python 移除字典点键值(key/value)对 Python 合并字典 Python 将字符串的时间转换为时间戳 Python 获取几天前的时间 Python 将时间戳转换为指定格式日期 Python 打印自己设计的字体 Python 二分查找 Python 线性查找 Python 插入排序 Python 快速排序 Python 选择排序 Python 冒泡排序 Python 归并排序 Python 堆排序 Python 计数排序 Python 希尔排序 Python 拓扑排序
	Python3 面向对象

 Python3 面向对象 
 
 面向对象技术简介 
 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法： 类中定义的函数。 类变量： 类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员： 类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写： 如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量： 定义在方法中的变量，只作用于当前实例的类。 实例变量： 在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承： 即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。 实例化： 创建一个类的实例，类的具体对象。 对象： 通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。 
 类定义 
 语法格式如下： class  ClassName statement - 1 statement - N > 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 
 类对象 
 类对象支持两种操作：属性引用和实例化。 obj.name 。 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: 实例(Python 3.0+) #!/usr/bin/python3 class  MyClass """ 一个简单的类实例 """ i = 12345 def  f ( self ) return  ' hello world ' # 实例化类 x = MyClass ( ) # 访问类的属性和方法 print ( " MyClass 类的属性 i 为： " , x . i ) print ( " MyClass 类的方法 f 输出为： " , x . f ( ) ) 以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。 执行以上程序输出结果为： 类有一个名为 __init__() 的特殊方法（ 构造方法 def  __init__ ( self ) self . data = [ ] 类定义了 __init__() 方法，类的实例化操作会自动调用 __init__() 方法。如下实例化类 MyClass，对应的 __init__() 方法就会被调用: 实例(Python 3.0+) #!/usr/bin/python3 class  Complex def  __init__ ( self , realpart , imagpart ) self . r = realpart self . i = imagpart x = Complex ( 3.0 , - 4.5 ) print ( x . r , x . i )  # 输出结果：3.0 -4.5 
 self代表类的实例，而非类 
 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的 第一个参数名称 , 按照惯例它的名称是 self。 class  Test def  prt ( self ) print ( self ) print ( self . __class__ ) t = Test ( ) t . prt ( ) 以上实例执行结果为： 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: class  Test def  prt ( runoob ) print ( runoob ) print ( runoob . __class__ ) t = Test ( ) t . prt ( ) 以上实例执行结果为： 
 类的方法 
 def 实例(Python 3.0+) #!/usr/bin/python3 #类定义 class  people #定义基本属性 name = ' ' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def  __init__ ( self , n , a , w ) self . name = n self . age = a self . __weight = w def  speak ( self ) print ( " %s 说: 我 %d 岁。 " % ( self . name , self . age ) ) # 实例化类 p = people ( ' runoob ' , 10 , 30 ) p . speak ( ) 执行以上程序输出结果为： 
 继承 
 Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: class  DerivedClassName ( BaseClassName1 ) statement - 1 statement - N > 实例(Python 3.0+) #!/usr/bin/python3 #类定义 class  people #定义基本属性 name = ' ' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def  __init__ ( self , n , a , w ) self . name = n self . age = a self . __weight = w def  speak ( self ) print ( " %s 说: 我 %d 岁。 " % ( self . name , self . age ) ) #单继承示例 class  student ( people ) grade = ' ' def  __init__ ( self , n , a , w , g ) #调用父类的构函 people . __init__ ( self , n , a , w ) self . grade = g #覆写父类的方法 def  speak ( self ) print ( " %s 说: 我 %d 岁了，我在读 %d 年级 " % ( self . name , self . age , self . grade ) ) s = student ( ' ken ' , 10 , 60 , 3 ) s . speak ( ) 执行以上程序输出结果为： 
 多继承 
 Python同样有限的支持多继承形式。多继承的类定义形如下例: class  DerivedClassName ( Base1 , Base2 , Base3 ) statement - 1 statement - N > 实例(Python 3.0+) #!/usr/bin/python3 #类定义 class  people #定义基本属性 name = ' ' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def  __init__ ( self , n , a , w ) self . name = n self . age = a self . __weight = w def  speak ( self ) print ( " %s 说: 我 %d 岁。 " % ( self . name , self . age ) ) #单继承示例 class  student ( people ) grade = ' ' def  __init__ ( self , n , a , w , g ) #调用父类的构函 people . __init__ ( self , n , a , w ) self . grade = g #覆写父类的方法 def  speak ( self ) print ( " %s 说: 我 %d 岁了，我在读 %d 年级 " % ( self . name , self . age , self . grade ) ) #另一个类，多重继承之前的准备 class  speaker ( ) topic = ' ' name = ' ' def  __init__ ( self , n , t ) self . name = n self . topic = t def  speak ( self ) print ( " 我叫 %s，我是一个演说家，我演讲的主题是 %s " % ( self . name , self . topic ) ) #多重继承 class  sample ( speaker , student ) a = ' ' def  __init__ ( self , n , a , w , g , t ) student . __init__ ( self , n , a , w , g ) speaker . __init__ ( self , n , t ) test = sample ( " Tim " , 25 , 80 , 4 , " Python " ) test . speak ( )  #方法名同，默认调用的是在括号中排前地父类的方法 执行以上程序输出结果为： 实例(Python 3.0+) #!/usr/bin/python3 class  Parent : # 定义父类 def  myMethod ( self ) print  ( ' 调用父类方法 ' ) class  Child ( Parent ) : # 定义子类 def  myMethod ( self ) print  ( ' 调用子类方法 ' ) c = Child ( )  # 子类实例 c . myMethod ( )  # 子类调用重写方法 super ( Child , c ) . myMethod ( )  #用子类对象调用父类已被覆盖的方法 super() 函数 是用于调用父类(超类)的一个方法。 执行以上程序输出结果为： 更多文档： Python 子类继承父类构造函数说明 
 类属性与方法 
 
 类的私有属性 
 __private_attrs ：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 。 
 类的方法 
 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self ，且为第一个参数， self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this ，但是最好还是按照约定是用 self 。 
 类的私有方法 
 __private_method ：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。 self.__private_methods 
 实例 
 类的私有属性实例如下： 实例(Python 3.0+) #!/usr/bin/python3 class  JustCounter __secretCount = 0  # 私有变量 publicCount = 0  # 公开变量 def  count ( self ) self . __secretCount += 1 self . publicCount += 1 print  ( self . __secretCount ) counter = JustCounter ( ) counter . count ( ) counter . count ( ) print  ( counter . publicCount ) print  ( counter . __secretCount )  # 报错，实例不能访问私有变量 执行以上程序输出结果为： 类的私有方法实例如下： 实例(Python 3.0+) #!/usr/bin/python3 class  Site def  __init__ ( self , name , url ) self . name = name  # public self . __url = url  # private def  who ( self ) print ( ' name  : ' , self . name ) print ( ' url : ' , self . __url ) def  __foo ( self ) : # 私有方法 print ( ' 这是私有方法 ' ) def  foo ( self ) : # 公共方法 print ( ' 这是公共方法 ' ) self . __foo ( ) x = Site ( ' 菜鸟教程 ' , ' www.runoob.com ' ) x . who ( )  # 正常输出 x . foo ( )  # 正常输出 x . __foo ( )  # 报错 以上实例执行结果： __init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 函数调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __truediv__: 除运算 __mod__: 求余运算 __pow__: 乘方 
 运算符重载 
 Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下： 实例(Python 3.0+) #!/usr/bin/python3 class  Vector def  __init__ ( self , a , b ) self . a = a self . b = b def  __str__ ( self ) return  ' Vector (%d, %d) ' % ( self . a , self . b ) def  __add__ ( self , other ) return  Vector ( self . a + other . a , self . b + other . b ) v1 = Vector ( 2 , 10 ) v2 = Vector ( 5 ,- 2 ) print  ( v1 + v2 ) 以上代码执行结果如下所示:
	Python3 错误和异常

 Python3 错误和异常 
 作为 Python 初学者，在刚学习 Python 编程时，经常会看到一些报错信息，在前面我们没有提及，这章节我们会专门介绍。 Python 有两种错误很容易辨认：语法错误和异常。 Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。 
 语法错误 
 Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例 >>>  while  True  print ( 'Hello world' ) "<stdin>" , line 1 ,  in ? while  True  print ( 'Hello world' ) SyntaxError : invalid syntax 这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号 : 。 
 异常 
 即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。 大多数的异常都不会被程序处理，都以错误信息的形式展现在这里: 实例 >>>  10 * ( 1 / 0 )  # 0 不能作为除数，触发异常 ( most recent call last ) : "<stdin>" , line 1 ,  in ? ZeroDivisionError : division by zero >>>  4 + spam* 3  # spam 未定义，触发异常 ( most recent call last ) : "<stdin>" , line 1 ,  in ? NameError : name 'spam'  is  not defined >>>  '2' + 2  # int 不能与 str 相加，触发异常 ( most recent call last ) : "<stdin>" , line 1 ,  in  < module > TypeError : can only concatenate str  ( not  "int" ) to str 
 异常处理 
 
 try/except 
 异常捕捉可以使用 
 try/except 
 语句。 while  True : try : =  int ( input ( "请输入一个数字: " ) ) break except  ValueError : print ( "您输入的不是数字，请再次尝试输入！" )  try 语句按照如下方式工作； 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。 如果没有异常发生，忽略 except 子句，try 子句执行后结束。 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。 如果一个异常没有与任何的 except  匹配，那么这个异常将会传递给上层的 try 中。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 except  ( RuntimeError ,  TypeError ,  NameError ) : pass 最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。 import  sys try : =  open ( 'myfile.txt' ) = f. readline ( ) =  int ( s. strip ( ) ) except  OSError  as err: print ( "OS error: {0}" . format ( err ) ) except  ValueError : print ( "Could not convert data to an integer." ) except : print ( "Unexpected error:" ,  sys . exc_info ( ) [ 0 ] ) raise 
 try/except...else 
 
 try/except 
 语句还有一个可选的 else for arg in  sys . argv [ 1 : ] : try : =  open ( arg ,  'r' ) except  IOError : print ( 'cannot open' , arg ) else : print ( arg ,  'has' ,  len ( f. readlines ( ) ) ,  'lines' ) close ( ) 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如: >>>  def this_fails ( ) : =  1 / 0 >>>  try : ( ) except  ZeroDivisionError  as err: print ( 'Handling run-time error:' , err ) time error: int division or modulo by zero 
 try-finally 语句 
 try-finally 语句无论是否发生异常都将执行最后的代码。 以下实例中 finally 语句无论异常是否发生都会执行： 实例  try : ( ) except  AssertionError  as error: print ( error ) else : try : with  open ( 'file.log' )  as  file : =  file . read ( ) except FileNotFoundError as fnf_error: print ( fnf_error ) finally : print ( '这句话，无论异常是否发生都会执行。' ) 
 抛出异常 
 raise语法格式如下： raise [Exception [, args [, traceback]]] =  10 if x >  5 : raise  Exception ( 'x 不能大于 5。x 的值为: {}' . format ( x ) ) 执行以上代码会触发异常： raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。 如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。 >>>  try : raise  NameError ( 'HiThere' ) except  NameError : print ( 'An exception flew by!' ) raise ! ( most recent call last ) : "<stdin>" , line 2 ,  in ? NameError : HiThere 
 用户自定义异常 
 你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如: >>>  class MyError ( Exception ) : def  __init__ ( self , value ) : self . value  = value def  __str__ ( self ) : return  repr ( self . value ) >>>  try : raise MyError ( 2 * 2 ) except MyError as e: print ( 'My exception occurred, value:' , e. value ) , value: 4 >>>  raise MyError ( 'oops!' ) ( most recent call last ) : "<stdin>" , line 1 ,  in ? __main__ . MyError : 'oops!' 在这个例子中，类 Exception 默认的 __init__() 被覆盖。 当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类: class Error ( Exception ) : """Base class for exceptions in this module.""" pass class InputError ( Error ) : """Exception raised for errors in the input. def  __init__ ( self , expression , message ) : self . expression  = expression self . message  = message class TransitionError ( Error ) : """Raised when an operation attempts a state transition that's not def  __init__ ( self , previous , next , message ) : self . previous  = previous self . next  = next self . message  = message 大多数的异常的名字都以"Error"结尾，就跟标准的异常命名一样。 
 定义清理行为 
 try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如: >>>  try : raise  KeyboardInterrupt finally : print ( 'Goodbye, world!' ) Goodbye , world ! ( most recent call last ) : "<stdin>" , line 2 ,  in  < module > KeyboardInterrupt 以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。 下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）: >>>  def divide ( x , y ) : try : = x / y except  ZeroDivisionError : print ( "division by zero!" ) else : print ( "result is" , result ) finally : print ( "executing finally clause" ) >>> divide ( 2 ,  1 ) is  2.0 finally clause >>> divide ( 2 ,  0 ) ! finally clause >>> divide ( "2" ,  "1" ) finally clause ( most recent call last ) : "<stdin>" , line 1 ,  in ? "<stdin>" , line 3 ,  in divide TypeError : unsupported operand type ( s )  for /: 'str'  and  'str' 
 预定义的清理行为 
 一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。 for line in  open ( "myfile.txt" ) : print ( line , end = "" ) 以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。 关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法: with  open ( "myfile.txt" )  as f: for line in f: print ( line , end = "" ) 
 相关内容 
 Python assert（断言）
	Python3 网络编程

 Python3 网络编程 
 Python 提供了两个级别访问的网络服务。： 低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。 高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。 
 什么是 Socket? 
 Socket又称"套接字"，应用程序通常通过"套接字"向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 
 socket()函数 
 Python 中，我们用 socket() 函数来创建套接字，语法格式如下： 
 参数 
 family: 套接字家族可以是 AF_UNIX 或者 AF_INET type: 套接字类型可以根据是面向连接的还是非连接分为 SOCK_STREAM 或 SOCK_DGRAM protocol: 一般不填默认为0. 
 Socket 对象(内建)方法 
 函数 描述 服务器端套接字 s.bind() 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来 客户端套接字 s.connect() 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。 s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常 公共用途的套接字函数 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 s.sendall() 完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。 s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。 s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 s.close() 关闭套接字 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。 s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port) s.setsockopt(level,optname,value) 设置给定套接字选项的值。 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值。 s.settimeout(timeout) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()） s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。 s.fileno() 返回套接字的文件描述符。 s.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。 s.makefile() 创建一个与该套接字相关连的文件 
 简单实例 
 
 服务端 
 我们使用 socket 模块的 socket 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。 现在我们可以通过调用 bind(hostname, port) 函数来指定服务的 port(端口) 。 接着，我们调用 socket 对象的 accept 方法。该方法等待客户端的连接，并返回 connection 对象，表示已连接到客户端。 完整代码如下： 
 客户端 
 接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 9999。 socket.connect(hosname, port ) 方法打开一个 TCP 连接到主机为 hostname 端口为 port 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。 完整代码如下： 现在我们打开两个终端，第一个终端执行 server.py 文件： $ python3 server.py 第二个终端执行 client.py 文件： 这时我们再打开第一个终端，就会看到有以下信息输出： 
 Python Internet 模块 
 以下列出了 Python 网络编程的一些重要模块： 协议 功能用处 端口号 Python 模块 HTTP 网页访问 80 httplib, urllib, xmlrpclib NNTP 阅读和张贴新闻文章，俗称为"帖子" 119 nntplib FTP 文件传输 20 ftplib, urllib SMTP 发送邮件 25 smtplib POP3 接收邮件 110 poplib IMAP4 获取邮件 143 imaplib Telnet 命令行 23 telnetlib Gopher 信息查找 70 gopherlib, urllib 更多内容可以参阅官网的 Python Socket Library and Modules 。
	Python3 多线程

 Python3 多线程 
 多线程类似于同时执行多个不同程序，多线程运行有如下优点： 使用线程可以把占据长时间的程序中的任务放到后台去处理。 用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。 程序的运行速度可能加快。 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。 线程可以被抢占（中断）。 线程可以分为: 内核线程： 由操作系统内核创建和撤销。 用户线程： 不需要内核支持而在用户程序中实现的线程。 Python3 线程中常用的两个模块为： _thread threading(推荐使用) thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用"thread" 模块。为了兼容性，Python3 将 thread 重命名为 "_thread"。 
 开始学习Python线程 
 Python中使用线程有两种方式：函数或者用类来包装线程对象。 函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下: 参数说明: function - 线程函数。 args - 传递给线程函数的参数,他必须是个tuple类型。 kwargs - 可选参数。 实例  #!/usr/bin/python3 import _thread import  time # 为线程定义一个函数 def print_time ( threadName , delay ) : =  0 while count <  5 : time . sleep ( delay ) =  1 print  ( "%s: %s" % ( threadName ,  time . ctime ( time . time ( ) )  ) ) # 创建两个线程 try : start_new_thread ( print_time ,  ( "Thread-1" ,  2 ,  )  ) start_new_thread ( print_time ,  ( "Thread-2" ,  4 ,  )  ) except : print  ( "Error: 无法启动线程" ) while  1 : pass 执行以上程序输出结果如下： 执行以上程后可以按下 ctrl-c 退出。 
 线程模块 
 Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。 threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法: run(): 用以表示线程活动的方法。 start(): 启动线程活动。 join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 
 使用 threading 模块创建线程 
 我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run()  方法： 实例  #!/usr/bin/python3 import  threading import  time =  0 class myThread ( threading . Thread ) : def  __init__ ( self , threadID , name , counter ) : threading . Thread . __init__ ( self ) self . threadID  = threadID self . name  = name self . counter  = counter def run ( self ) : print  ( "开始线程：" + self . name ) ( self . name ,  self . counter ,  5 ) print  ( "退出线程：" + self . name ) def print_time ( threadName , delay , counter ) : while counter: if exitFlag: exit ( ) time . sleep ( delay ) print  ( "%s: %s" % ( threadName ,  time . ctime ( time . time ( ) ) ) ) =  1 # 创建新线程 = myThread ( 1 ,  "Thread-1" ,  1 ) = myThread ( 2 ,  "Thread-2" ,  2 ) # 开启新线程 start ( ) start ( ) join ( ) join ( ) print  ( "退出主线程" ) 以上程序执行结果如下； 
 线程同步 
 多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。 实例  #!/usr/bin/python3 import  threading import  time class myThread ( threading . Thread ) : def  __init__ ( self , threadID , name , counter ) : threading . Thread . __init__ ( self ) self . threadID  = threadID self . name  = name self . counter  = counter def run ( self ) : print  ( "开启线程： " + self . name ) # 获取锁，用于线程同步 acquire ( ) ( self . name ,  self . counter ,  3 ) # 释放锁，开启下一个线程 release ( ) def print_time ( threadName , delay , counter ) : while counter: time . sleep ( delay ) print  ( "%s: %s" % ( threadName ,  time . ctime ( time . time ( ) ) ) ) =  1 =  threading . Lock ( ) =  [ ] # 创建新线程 = myThread ( 1 ,  "Thread-1" ,  1 ) = myThread ( 2 ,  "Thread-2" ,  2 ) # 开启新线程 start ( ) start ( ) # 添加线程到线程列表 append ( thread1 ) append ( thread2 ) # 等待所有线程完成 for t in threads: join ( ) print  ( "退出主线程" ) 执行以上程序，输出结果为： 这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。 Queue 模块中的常用方法: Queue.qsize() 返回队列的大小 Queue.empty() 如果队列为空，返回True,反之False Queue.full() 如果队列满了，返回True,反之False Queue.full 与 maxsize 大小对应 Queue.get([block[, timeout]])获取队列，timeout等待时间 Queue.get_nowait() 相当Queue.get(False) Queue.put(item) 写入队列，timeout等待时间 Queue.put_nowait(item) 相当Queue.put(item, False) Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号 Queue.join() 实际上意味着等到队列为空，再执行别的操作 实例  #!/usr/bin/python3 import queue import  threading import  time =  0 class myThread ( threading . Thread ) : def  __init__ ( self , threadID , name , q ) : threading . Thread . __init__ ( self ) self . threadID  = threadID self . name  = name self . q  = q def run ( self ) : print  ( "开启线程：" + self . name ) ( self . name ,  self . q ) print  ( "退出线程：" + self . name ) def process_data ( threadName , q ) : while  not exitFlag: acquire ( ) if  not workQueue. empty ( ) : = q. get ( ) release ( ) print  ( "%s processing %s" % ( threadName , data ) ) else : release ( ) time . sleep ( 1 ) =  [ "Thread-1" ,  "Thread-2" ,  "Thread-3" ] =  [ "One" ,  "Two" ,  "Three" ,  "Four" ,  "Five" ] =  threading . Lock ( ) = queue. Queue ( 10 ) =  [ ] =  1 # 创建新线程 for tName in threadList: thread  = myThread ( threadID , tName , workQueue ) thread . start ( ) append ( thread ) =  1 # 填充队列 acquire ( ) for word in nameList: put ( word ) release ( ) # 等待队列清空 while  not workQueue. empty ( ) : pass # 通知线程是时候退出 =  1 # 等待所有线程完成 for t in threads: join ( ) print  ( "退出主线程" ) 以上程序执行结果：
	Python3 OS 文件/目录方法

 Python3 OS 文件/目录方法 
 os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示： 序号 方法及描述 1 os.access(path, mode) 检验权限模式 2 os.chdir(path) 改变当前工作目录 3 os.chflags(path, flags) 设置路径的标记为数字标记。 4 os.chmod(path, mode) 更改权限 5 os.chown(path, uid, gid) 更改文件所有者 6 os.chroot(path) 改变当前进程的根目录 7 os.close(fd) 关闭文件描述符 fd 8 os.closerange(fd_low, fd_high) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 9 os.dup(fd) 复制文件描述符 fd 10 os.dup2(fd, fd2) 将一个文件描述符 fd 复制到另一个 fd2 11 os.fchdir(fd) 通过文件描述符改变当前工作目录 12 os.fchmod(fd, mode) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 13 os.fchown(fd, uid, gid) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 14 os.fdatasync(fd) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 15 os.fdopen(fd[, mode[, bufsize]]) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 16 os.fpathconf(fd, name) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 17 os.fstat(fd) 返回文件描述符fd的状态，像stat()。 18 os.fstatvfs(fd) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。 19 os.fsync(fd) 强制将文件描述符为fd的文件写入硬盘。 20 os.ftruncate(fd, length) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 21 os.getcwd() 返回当前工作目录 22 os.getcwdu() 返回一个当前工作目录的Unicode对象 23 os.isatty(fd) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 24 os.lchflags(path, flags) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 25 os.lchmod(path, mode) 修改连接文件权限 26 os.lchown(path, uid, gid) 更改文件所有者，类似 chown，但是不追踪链接。 27 os.link(src, dst) 创建硬链接，名为参数 dst，指向参数 src 28 os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 29 os.lseek(fd, pos, how) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 30 os.lstat(path) 像stat(),但是没有软链接 31 os.major(device) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 32 os.makedev(major, minor) 以major和minor设备号组成一个原始设备号 33 os.makedirs(path[, mode]) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 34 os.minor(device) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 35 os.mkdir(path[, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 36 os.mkfifo(path[, mode]) 创建命名管道，mode 为数字，默认为 0666 (八进制) 37 os.mknod(filename[, mode=0600, device]) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 38 os.open(file, flags[, mode]) 打开一个文件，并且设置需要的打开选项，mode参数是可选的 39 os.openpty() 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 40 os.pathconf(path, name) 41 os.pipe() 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 42 os.popen(command[, mode[, bufsize]]) 从一个 command 打开一个管道 43 os.read(fd, n) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 44 os.readlink(path) 返回软链接所指向的文件 45 os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 46 os.removedirs(path) 递归删除目录。 47 os.rename(src, dst) 重命名文件或目录，从 src 到 dst 48 os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。 49 os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 50 os.stat(path) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 51 os.stat_float_times([newvalue]) 决定stat_result是否以float对象显示时间戳 52 os.statvfs(path) 获取指定路径的文件系统统计信息 53 os.symlink(src, dst) 创建一个软链接 54 os.tcgetpgrp(fd) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 55 os.tcsetpgrp(fd, pg) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 56 os.tempnam([dir[, prefix]]) Python3 中已删除。 返回唯一的路径名用于创建临时文件。 57 os.tmpfile() Python3 中已删除。 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 58 os.tmpnam() Python3 中已删除。 为创建一个临时文件返回一个唯一的路径 59 os.ttyname(fd) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 60 os.unlink(path) 删除文件路径 61 os.utime(path, times) 返回指定的path文件的访问和修改的时间。 62 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 63 os.write(fd, str) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 64 os.path 模块 获取文件的属性信息。 65 os.pardir() 获取当前目录的父目录，以字符串形式显示目录名。
	Python3 输入和输出

 Python3 输入和输出 
 在前面几个章节中，我们其实已经接触了 Python 的输入输出的功能。本章节我们将具体介绍 Python 的输入输出。 输出格式美化 第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。 如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。 如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。 str()： 函数返回一个用户易读的表达形式。 repr()： 产生一个解释器易读的表达形式。  >>> s =  'Hello, Runoob' >>>  str ( s ) 'Hello, Runoob' >>>  repr ( s ) "'Hello, Runoob'" >>>  str ( 1 / 7 ) '0.14285714285714285' >>> x =  10 * 3.25 >>> y =  200 * 200 >>> s =  'x 的值为： ' + repr ( x ) + ',  y 的值为：' + repr ( y ) + '...' >>>  print ( s ) 32.5 , y 的值为： 40000 ... >>>  #  repr() 函数可以转义字符串中的特殊字符 hello  =  'hello, runoob \n ' >>> hellos =  repr ( hello ) >>>  print ( hellos ) 'hello, runoob \n ' >>>  # repr() 的参数可以是 Python 的任何对象 repr ( ( x , y ,  ( 'Google' ,  'Runoob' ) ) ) "(32.5, 40000, ('Google', 'Runoob'))"  >>>  for x in  range ( 1 ,  11 ) : print ( repr ( x ) . rjust ( 2 ) ,  repr ( x*x ) . rjust ( 3 ) , end = ' ' ) # 注意前一行 'end' 的使用 print ( repr ( x*x*x ) . rjust ( 4 ) ) 1  1  1 2  4  8 3  9  27 4  16  64 5  25  125 6  36  216 7  49  343 8  64  512 9  81  729 10  100  1000 >>>  for x in  range ( 1 ,  11 ) : print ( '{0:2d} {1:3d} {2:4d}' . format ( x , x*x , x*x*x ) ) 1  1  1 2  4  8 3  9  27 4  16  64 5  25  125 6  36  216 7  49  343 8  64  512 9  81  729 10  100  1000 注意： 在第一个例子中, 每列间的空格由 print() 添加。 >>>  '12' . zfill ( 5 ) '00012' >>>  '-3.14' . zfill ( 7 ) '-003.14' >>>  '3.14159265359' . zfill ( 5 ) '3.14159265359' str.format() 的基本使用如下:  >>>  print ( '{}网址： "{}!"' . format ( '菜鸟教程' ,  'www.runoob.com' ) ) "www.runoob.com!" 括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。 在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：  >>>  print ( '{0} 和 {1}' . format ( 'Google' ,  'Runoob' ) ) >>>  print ( '{1} 和 {0}' . format ( 'Google' ,  'Runoob' ) )  >>>  print ( '{name}网址： {site}' . format ( name = '菜鸟教程' ,  site = 'www.runoob.com' ) ) runoob . com >>>  print ( '站点列表 {0}, {1}, 和 {other}。' . format ( 'Google' ,  'Runoob' , other = 'Taobao' ) ) , Runoob , 和 Taobao。  !a (使用 ascii() ), !s (使用 str() ) 和 !r (使用 repr() ) 可以用于在格式化某个值之前对其进行转化:  >>>  import  math >>>  print ( '常量 PI 的值近似为： {}。' . format ( math . pi ) ) 3.141592653589793 。 >>>  print ( '常量 PI 的值近似为： {!r}。' . format ( math . pi ) ) 3.141592653589793 。 可选项 : >>>  import  math >>>  print ( '常量 PI 的值近似为 {0:.3f}。' . format ( math . pi ) ) 3.142 。 : >>> table =  { 'Google' : 1 ,  'Runoob' : 2 ,  'Taobao' : 3 } >>>  for name , number in table. items ( ) : print ( '{0:10} ==> {1:10d}' . format ( name , number ) ) Google  ==>  1 ==>  2 ==>  3 最简单的就是传入一个字典, 然后使用方括号 [] 来访问键值 :  >>> table =  { 'Google' : 1 ,  'Runoob' : 2 ,  'Taobao' : 3 } >>>  print ( 'Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}' . format ( table ) ) 2 ; Google: 1 ; Taobao: 3 ** 来实现相同的功能：  >>> table =  { 'Google' : 1 ,  'Runoob' : 2 ,  'Taobao' : 3 } >>>  print ( 'Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}' . format ( **table ) ) 2 ; Google: 1 ; Taobao: 3 
 旧式字符串格式化 
 % 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf()  >>>  import  math >>>  print ( '常量 PI 的值近似为：%5.3f。' % math . pi ) 3.142 。 
 读取键盘输入 
 实例  #!/usr/bin/python3 str  =  input ( "请输入：" ) ; print  ( "你输入的内容是: " ,  str )  filename：包含了你要访问的文件名称的字符串值。 mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。  不同模式打开文件的完全列表：  模式 描述  r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。  rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。  r+ 打开一个文件用于读写。文件指针将会放在文件的开头。  rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。  w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。  wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。  w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。  wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。  a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。  ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。  a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。  ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。  下图很好的总结了这几种模式： 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + 以下实例将字符串写入到文件 foo.txt 中： 实例  #!/usr/bin/python3 # 打开一个文件 =  open ( "/tmp/foo.txt" ,  "w" ) write (  "Python 是一个非常好的语言。 \n 是的，的确非常好!! \n "  ) # 关闭打开的文件 close ( ) 
 文件对象的方法 
 
 f.read() 
 size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。 以下实例假定文件 foo.txt 已存在（上面实例中已创建）： 实例  #!/usr/bin/python3 # 打开一个文件 =  open ( "/tmp/foo.txt" ,  "r" ) str  = f. read ( ) print ( str ) # 关闭打开的文件 close ( ) 执行以上程序，输出结果为： 
 f.readline() 
 实例  #!/usr/bin/python3 # 打开一个文件 =  open ( "/tmp/foo.txt" ,  "r" ) str  = f. readline ( ) print ( str ) # 关闭打开的文件 close ( ) 执行以上程序，输出结果为： 
 f.readlines() 
 实例  #!/usr/bin/python3 # 打开一个文件 =  open ( "/tmp/foo.txt" ,  "r" ) str  = f. readlines ( ) print ( str ) # 关闭打开的文件 close ( ) 执行以上程序，输出结果为： 实例  #!/usr/bin/python3 # 打开一个文件 =  open ( "/tmp/foo.txt" ,  "r" ) for line in f: print ( line , end = '' ) # 关闭打开的文件 close ( ) 执行以上程序，输出结果为： 
 f.write() 
 实例  #!/usr/bin/python3 # 打开一个文件 =  open ( "/tmp/foo.txt" ,  "w" ) = f. write (  "Python 是一个非常好的语言。 \n 是的，的确非常好!! \n "  ) print ( num ) # 关闭打开的文件 close ( ) 执行以上程序，输出结果为： 实例  #!/usr/bin/python3 # 打开一个文件 =  open ( "/tmp/foo1.txt" ,  "w" ) =  ( 'www.runoob.com' ,  14 ) =  str ( value ) write ( s ) # 关闭打开的文件 close ( ) 执行以上程序，打开 foo1.txt 文件： 
 f.tell() 
 
 f.seek() 
 如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。 >>> f =  open ( '/tmp/foo.txt' ,  'rb+' ) >>> f. write ( b '0123456789abcdef' ) 16 >>> f. seek ( 5 )  # 移动到文件的第六个字节 5 >>> f. read ( 1 ) '5' >>> f. seek ( - 3 ,  2 )  # 移动到文件的倒数第三字节 13 >>> f. read ( 1 ) 'd' 
 f.close() 
 >>> f. close ( ) >>> f. read ( ) ( most recent call last ) : "<stdin>" , line 1 ,  in ? ValueError : I/O operation on closed file >>>  with  open ( '/tmp/foo.txt' ,  'r' )  as f: read_data  = f. read ( ) >>> f. closed True 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。 注解： 从 file 中读取一个字符串，并将它重构为原来的python对象。 file: 类文件对象，有read()和readline()接口。 实例 1  #!/usr/bin/python3 import  pickle # 使用pickle模块将数据对象保存到文件 =  { 'a' : [ 1 ,  2.0 ,  3 ,  4 +6j ] , 'b' : ( 'string' , u 'Unicode string' ) , 'c' : None } =  [ 1 ,  2 ,  3 ] append ( selfref_list ) =  open ( 'data.pkl' ,  'wb' ) # Pickle dictionary using protocol 0. pickle . dump ( data1 , output ) # Pickle the list using the highest protocol available. pickle . dump ( selfref_list , output , - 1 ) close ( ) 实例 2  #!/usr/bin/python3 import  pprint ,  pickle #使用pickle模块从文件中重构python对象 =  open ( 'data.pkl' ,  'rb' ) =  pickle . load ( pkl_file ) pprint . pprint ( data1 ) =  pickle . load ( pkl_file ) pprint . pprint ( data2 ) close ( )
	Python3 数据结构

 Python3 数据结构 
 本章节我们主要结合前面所学的知识点来介绍Python数据结构。 
 列表 
 以下是 Python 中列表的方法： 方法 描述 下面示例演示了列表的大部分方法： 实例  >>> a =  [ 66.25 ,  333 ,  333 ,  1 ,  1234.5 ] >>>  print ( a. count ( 333 ) , a. count ( 66.25 ) , a. count ( 'x' ) ) 2  1  0 >>> a. insert ( 2 , - 1 ) >>> a. append ( 333 ) >>> a [ 66.25 ,  333 , - 1 ,  333 ,  1 ,  1234.5 ,  333 ] >>> a. index ( 333 ) 1 >>> a. remove ( 333 ) >>> a [ 66.25 , - 1 ,  333 ,  1 ,  1234.5 ,  333 ] >>> a. reverse ( ) >>> a [ 333 ,  1234.5 ,  1 ,  333 , - 1 ,  66.25 ] >>> a. sort ( ) >>> a [ - 1 ,  1 ,  66.25 ,  333 ,  333 ,  1234.5 ] 注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。 
 将列表当做堆栈使用 
 实例  >>> stack =  [ 3 ,  4 ,  5 ] >>> stack. append ( 6 ) >>> stack. append ( 7 ) >>> stack [ 3 ,  4 ,  5 ,  6 ,  7 ] >>> stack. pop ( ) 7 >>> stack [ 3 ,  4 ,  5 ,  6 ] >>> stack. pop ( ) 6 >>> stack. pop ( ) 5 >>> stack [ 3 ,  4 ] 
 将列表当作队列使用 
 实例  >>>  from  collections  import deque >>> queue = deque ( [ "Eric" ,  "John" ,  "Michael" ] ) >>> queue. append ( "Terry" )  # Terry arrives >>> queue. append ( "Graham" )  # Graham arrives >>> queue. popleft ( )  # The first to arrive now leaves 'Eric' >>> queue. popleft ( )  # The second to arrive now leaves 'John' >>> queue # Remaining queue in order of arrival ( [ 'Michael' ,  'Terry' ,  'Graham' ] ) 
 列表推导式 
 这里我们将列表中每个数值乘三，获得一个新的列表：  >>> vec =  [ 2 ,  4 ,  6 ] >>>  [ 3 *x for x in vec ] [ 6 ,  12 ,  18 ] 现在我们玩一点小花样： >>>  [ [ x , x** 2 ]  for x in vec ] [ [ 2 ,  4 ] ,  [ 4 ,  16 ] ,  [ 6 ,  36 ] ] 实例  >>> freshfruit =  [ '  banana' ,  '  loganberry ' ,  'passion fruit  ' ] >>>  [ weapon. strip ( )  for weapon in freshfruit ] [ 'banana' ,  'loganberry' ,  'passion fruit' ] 我们可以用 if 子句作为过滤器：  >>>  [ 3 *x for x in vec if x >  3 ] [ 12 ,  18 ] >>>  [ 3 *x for x in vec if x <  2 ] [ ] 以下是一些关于循环和其它技巧的演示：  >>> vec1 =  [ 2 ,  4 ,  6 ] >>> vec2 =  [ 4 ,  3 , - 9 ] >>>  [ x*y for x in vec1 for y in vec2 ] [ 8 ,  6 , - 18 ,  16 ,  12 , - 36 ,  24 ,  18 , - 54 ] >>>  [ x+y for x in vec1 for y in vec2 ] [ 6 ,  5 , - 7 ,  8 ,  7 , - 5 ,  10 ,  9 , - 3 ] >>>  [ vec1 [ i ] *vec2 [ i ]  for i in  range ( len ( vec1 ) ) ] [ 8 ,  12 , - 54 ]  >>>  [ str ( round ( 355 / 113 , i ) )  for i in  range ( 1 ,  6 ) ] [ '3.1' ,  '3.14' ,  '3.142' ,  '3.1416' ,  '3.14159' ] 
 嵌套列表解析 
 以下实例展示了3X4的矩阵列表：  >>> matrix =  [ [ 1 ,  2 ,  3 ,  4 ] , [ 5 ,  6 ,  7 ,  8 ] , [ 9 ,  10 ,  11 ,  12 ] , ] 以下实例将3X4的矩阵列表转换为4X3列表：  >>>  [ [ row [ i ]  for row in matrix ]  for i in  range ( 4 ) ] [ [ 1 ,  5 ,  9 ] ,  [ 2 ,  6 ,  10 ] ,  [ 3 ,  7 ,  11 ] ,  [ 4 ,  8 ,  12 ] ] 以下实例也可以使用以下方法来实现：  >>> transposed =  [ ] >>>  for i in  range ( 4 ) : transposed . append ( [ row [ i ]  for row in matrix ] ) >>> transposed [ [ 1 ,  5 ,  9 ] ,  [ 2 ,  6 ,  10 ] ,  [ 3 ,  7 ,  11 ] ,  [ 4 ,  8 ,  12 ] ] 另外一种实现方法：  >>> transposed =  [ ] >>>  for i in  range ( 4 ) : # the following 3 lines implement the nested listcomp transposed_row  =  [ ] for row in matrix: transposed_row . append ( row [ i ] ) transposed . append ( transposed_row ) >>> transposed [ [ 1 ,  5 ,  9 ] ,  [ 2 ,  6 ,  10 ] ,  [ 3 ,  7 ,  11 ] ,  [ 4 ,  8 ,  12 ] ] 
 del 语句 
  >>> a =  [ - 1 ,  1 ,  66.25 ,  333 ,  333 ,  1234.5 ] >>>  del a [ 0 ] >>> a [ 1 ,  66.25 ,  333 ,  333 ,  1234.5 ] >>>  del a [ 2 : 4 ] >>> a [ 1 ,  66.25 ,  1234.5 ] >>>  del a [ : ] >>> a [ ] 也可以用 del 删除实体变量： 
 元组和序列 
  >>> t =  12345 ,  54321 ,  'hello!' >>> t [ 0 ] 12345 >>> t ( 12345 ,  54321 ,  'hello!' ) >>>  # Tuples may be nested: u  = t ,  ( 1 ,  2 ,  3 ,  4 ,  5 ) >>> u ( ( 12345 ,  54321 ,  'hello!' ) ,  ( 1 ,  2 ,  3 ,  4 ,  5 ) ) 
 集合 
 集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。 可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。 以下是一个简单的演示：  >>> basket =  { 'apple' ,  'orange' ,  'apple' ,  'pear' ,  'orange' ,  'banana' } >>>  print ( basket )  # 删除重复的 { 'orange' ,  'banana' ,  'pear' ,  'apple' } >>>  'orange'  in basket # 检测成员 True >>>  'crabgrass'  in basket False >>>  # 以下演示了两个集合的操作 >>> a =  set ( 'abracadabra' ) >>> b =  set ( 'alacazam' ) >>> a # a 中唯一的字母 { 'a' ,  'r' ,  'b' ,  'c' ,  'd' } >>> a - b # 在 a 中的字母，但不在 b 中 { 'r' ,  'd' ,  'b' } >>> a | b # 在 a 或 b 中的字母 { 'a' ,  'c' ,  'r' ,  'd' ,  'b' ,  'm' ,  'z' ,  'l' } >>> a & b # 在 a 和 b 中都有的字母 { 'a' ,  'c' } >>> a ^ b # 在 a 或 b 中的字母，但不同时在 a 和 b 中 { 'r' ,  'd' ,  'b' ,  'm' ,  'z' ,  'l' } 集合也支持推导式：  >>> a =  { x for x in  'abracadabra'  if x not  in  'abc' } >>> a { 'r' ,  'd' } 
 字典 
 另一个非常有用的 Python 内建数据类型是字典。 序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。 理解字典的最佳方式是把它看做无序的键=>值对集合。在同一个字典之内，关键字必须是互不相同。 一对大括号创建一个空的字典：{}。 这是一个字典运用的简单例子：  >>> tel =  { 'jack' : 4098 ,  'sape' : 4139 } >>> tel [ 'guido' ]  =  4127 >>> tel { 'sape' : 4139 ,  'guido' : 4127 ,  'jack' : 4098 } >>> tel [ 'jack' ] 4098 >>>  del tel [ 'sape' ] >>> tel [ 'irv' ]  =  4127 >>> tel { 'guido' : 4127 ,  'irv' : 4127 ,  'jack' : 4098 } >>>  list ( tel. keys ( ) ) [ 'irv' ,  'guido' ,  'jack' ] >>>  sorted ( tel. keys ( ) ) [ 'guido' ,  'irv' ,  'jack' ] >>>  'guido'  in tel True >>>  'jack'  not  in tel False 构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：  >>>  dict ( [ ( 'sape' ,  4139 ) ,  ( 'guido' ,  4127 ) ,  ( 'jack' ,  4098 ) ] ) { 'sape' : 4139 ,  'jack' : 4098 ,  'guido' : 4127 } 此外，字典推导可以用来创建任意键和值的表达式词典：  >>>  { x: x** 2  for x in  ( 2 ,  4 ,  6 ) } { 2 : 4 ,  4 : 16 ,  6 : 36 } 如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：  >>>  dict ( sape = 4139 , guido = 4127 , jack = 4098 ) { 'sape' : 4139 ,  'jack' : 4098 ,  'guido' : 4127 } 
 遍历技巧 
  >>> knights =  { 'gallahad' : 'the pure' ,  'robin' : 'the brave' } >>>  for k , v in knights. items ( ) : print ( k , v ) gallahad the pure 在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：  >>>  for i , v in  enumerate ( [ 'tic' ,  'tac' ,  'toe' ] ) : print ( i , v ) 0 tic 1 tac 2 toe 同时遍历两个或更多的序列，可以使用 zip() 组合：  >>> questions =  [ 'name' ,  'quest' ,  'favorite color' ] >>> answers =  [ 'lancelot' ,  'the holy grail' ,  'blue' ] >>>  for q , a in  zip ( questions , answers ) : print ( 'What is your {0}?  It is {1}.' . format ( q , a ) ) What  is your name?  It is lancelot. What  is your quest?  It is the holy grail. What  is your favorite color?  It is blue. 要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：  >>>  for i in  reversed ( range ( 1 ,  10 ,  2 ) ) : print ( i ) 9 7 5 3 1 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：  >>> basket =  [ 'apple' ,  'orange' ,  'apple' ,  'pear' ,  'orange' ,  'banana' ] >>>  for f in  sorted ( set ( basket ) ) : print ( f ) apple 
 参阅文档 
 Python3 列表 Python3 元组 Python3 字典
	Python3 迭代器与生成器

 Python3 迭代器与生成器 
 
 迭代器 
 迭代是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 iter() 和 next() 字符串，列表或元组对象都可用于创建迭代器： 实例(Python 3.0+) >>>  list = [ 1 , 2 , 3 , 4 ] >>> it =  iter ( list )  # 创建迭代器对象 >>>  print  ( next ( it ) )  # 输出迭代器的下一个元素 1 >>>  print  ( next ( it ) ) 2 >>>  迭代器对象可以使用常规for语句进行遍历： 实例(Python 3.0+) #!/usr/bin/python3 list = [ 1 , 2 , 3 , 4 ] it = iter ( list )  # 创建迭代器对象 for  x  in  it print  ( x , end = "  " ) 执行以上程序，输出结果如下： 也可以使用  next() 函数： 实例(Python 3.0+) #!/usr/bin/python3 import  sys  # 引入 sys 模块 list = [ 1 , 2 , 3 , 4 ] it = iter ( list )  # 创建迭代器对象 while  True try print  ( next ( it ) ) except  
 StopIteration 
 sys . exit ( ) 执行以上程序，输出结果如下： 
 创建一个迭代器 
 把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。 如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 __init__(), 它会在对象初始化的时候执行。 更多内容查阅： Python3 面向对象 __iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。 __next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。 创建一个返回数字的迭代器，初始值为 1，逐步递增 1： 实例(Python 3.0+) class  MyNumbers def  __iter__ ( self ) self . a = 1 return  self def  __next__ ( self ) x = self . a self . a += 1 return  x myclass = MyNumbers ( ) myiter = iter ( myclass ) print ( next ( myiter ) ) print ( next ( myiter ) ) print ( next ( myiter ) ) print ( next ( myiter ) ) print ( next ( myiter ) ) 执行输出结果为： 
 StopIteration 
 StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在  __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 在 20 次迭代后停止执行： 实例(Python 3.0+) class  MyNumbers def  __iter__ ( self ) self . a = 1 return  self def  __next__ ( self ) if  self . a <= 20 x = self . a self . a += 1 return  x else raise  
 StopIteration 
 myclass = MyNumbers ( ) myiter = iter ( myclass ) for  x  in  myiter print ( x ) 执行输出结果为： 
 生成器 
 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 以下实例使用 yield 实现斐波那契数列： 实例(Python 3.0+) #!/usr/bin/python3 import  sys def  fibonacci ( n ) : # 生成器函数 - 斐波那契 a , b , counter = 0 , 1 , 0 while  True if  ( counter > n ) return yield  a a , b = b , a + b counter += 1 f = fibonacci ( 10 )  # f 是一个迭代器，由生成器返回生成 while  True try print  ( next ( f ) , end = "  " ) except  
 StopIteration 
 sys . exit ( ) 执行以上程序，输出结果如下：
	Python3 命名空间和作用域


 命名空间 
 先看看官方文档的一段话： A namespace is a mapping from names to objects.Most namespaces are currently implemented as Python dictionaries。 命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。 命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 一般有三种命名空间： 内置名称（built-in names ）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。 全局名称（global names） ，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。 局部名称（local names） ，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是） 命名空间查找顺序: 假设我们要使用变量 runoob，则 Python 的查找顺序为： 局部的命名空间去 -> 全局命名空间 -> 内置命名空间 。 如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常: NameError: name 'runoob' is not defined。 命名空间的生命周期： 命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。 实例  # var1 是全局名称 =  5 def some_func ( ) : # var2 是局部名称 =  6 def some_inner_func ( ) : # var3 是内嵌的局部名称 =  7 如下图所示，相同的对象名称可以存在于多个命名空间中。 
 作用域 
 A scope is a textual region of a Python program where a namespace is directly accessible. "Directly accessible" here means that an unqualified reference to a name attempts to find the name in the namespace. 作用域就是一个 Python 程序可以直接访问命名空间的正文区域。 在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。 Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是： 有四种作用域： L（Local） ：最内层，包含局部变量，比如一个函数/方法内部。 E（Enclosing） ：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。 G（Global） ：当前脚本的最外层，比如当前模块的全局变量。 B（Built-in） ： 包含了内建的变量/关键字等。，最后被搜索 规则顺序： L –> E –> G –>gt; B 。 在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量: Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码： 实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。 如果将 msg 定义在函数中，则它就是局部变量，外部不能访问： 从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。 
 全局变量和局部变量 
 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例： 实例(Python 3.0+) #!/usr/bin/python3 total = 0  # 这是一个全局变量 # 可写函数说明 def  sum (  arg1 , arg2  ) #返回2个参数的和." total = arg1 + arg2  # total在这里是局部变量. print  ( " 函数内是局部变量 : " , total ) return  total #调用sum函数 sum (  10 , 20  ) print  ( " 函数外是全局变量 : " , total ) 以上实例输出结果： 
 global 和 nonlocal关键字 
 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。 以下实例修改全局变量 num： 实例(Python 3.0+) #!/usr/bin/python3 num = 1 def  fun1 ( ) global  num  # 需要使用 global 关键字声明 print ( num ) num = 123 print ( num ) fun1 ( ) print ( num ) 以上实例输出结果： 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例： 实例(Python 3.0+) #!/usr/bin/python3 def  outer ( ) num = 10 def  inner ( ) nonlocal  num  # nonlocal关键字声明 num = 100 print ( num ) inner ( ) print ( num ) outer ( ) 以上实例输出结果： 另外有一种特殊情况，假设下面这段代码被运行： 实例(Python 3.0+) #!/usr/bin/python3 a = 10 def  test ( ) a = a + 1 print ( a ) test ( ) 错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。 修改 a 为全局变量，通过函数参数传递，可以正常执行输出结果为： 实例(Python 3.0+) #!/usr/bin/python3 a = 10 def  test ( a ) a = a + 1 print ( a ) test ( a ) 执行输出结果为：
	Python3 File(文件) 方法

 Python3 File(文件) 方法 
 Python  open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。 注意： 使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。 open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。 open(file, mode='r') 完整的语法格式为： open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明: file: 必需，文件路径（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: mode 参数有： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（ Python 3 不支持 ）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 默认为文本模式，如果要以二进制模式打开，加上 b 。 
 file 对象 
 序号 方法及描述 1 file.close() 关闭文件。关闭后文件不能再进行读写操作。 2 file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3 file.fileno() 4 file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。 5 file.next() Python 3 中的 File 对象不支持 next() 方法。 返回文件下一行。 6 file.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。 7 file.readline([size]) 读取整行，包括 "\n" 字符。 8 file.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 9 file.seek(offset[, whence]) 移动文件读取指针到指定位置 10 file.tell() 返回文件当前位置。 11 file.truncate([size]) 12 file.write(str) 将字符串写入文件，返回的是写入的字符长度。 13 file.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。
	Python3 函数

 Python3 函数 
 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。 函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。 
 定义一个函数 
 你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 () 。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 
 语法 
 Python 定义函数使用 def 关键字，一般格式如下： 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。 
 实例 
 让我们使用函数来输出"Hello World！"： >>> def  hello ( ) print ( " Hello World! " ) hello ( ) Hello  World 实例(Python 3.0+) #!/usr/bin/python3 # 计算面积函数 def  area ( width , height ) return  width * height def  print_welcome ( name ) print ( " Welcome " , name ) print_welcome ( " Runoob " ) w = 4 h = 5 print ( " width = " , w , " height = " , h , " area = " , area ( w , h ) ) 以上实例输出结果： 
 函数调用 
 定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。 如下实例调用了 printme() 函数： 实例(Python 3.0+) #!/usr/bin/python3 # 定义函数 def  printme (  str  ) # 打印任何传入的字符串 print  ( str ) return # 调用函数 printme ( " 我要调用用户自定义函数! " ) printme ( " 再次调用同一函数 " ) 以上实例输出结果： 
 参数传递 
 在 python 中，类型属于对象，变量是没有类型的： 以上代码中， [1,2,3] 是 List 类型， "Runoob" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 
 可更改(mutable)与不可更改(immutable)对象 
 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 变量赋值 a=5 后再赋值 a=10 ，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 
 python 传不可变对象实例 
 实例(Python 3.0+) #!/usr/bin/python3 def  ChangeInt (  a  ) a = 10 b = 2 ChangeInt ( b ) print (  b  )  # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 
 传可变对象实例 
 可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如： 实例(Python 3.0+) #!/usr/bin/python3 # 可写函数说明 def  changeme (  mylist  ) " 修改传入的列表 " mylist . append ( [ 1 , 2 , 3 , 4 ] ) print  ( " 函数内取值: " , mylist ) return # 调用changeme函数 mylist = [ 10 , 20 , 30 ] changeme (  mylist  ) print  ( " 函数外取值: " , mylist ) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 
 参数 
 以下是调用函数时可使用的正式参数类型： 
 必需参数 
 
 关键字参数 
 
 默认参数 
 
 不定长参数 
 
 必需参数 
 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用 printme() 函数，你必须传入一个参数，不然会出现语法错误： 实例(Python 3.0+) #!/usr/bin/python3 #可写函数说明 def  printme (  str  ) " 打印任何传入的字符串 " print  ( str ) return # 调用 printme 函数，不加参数会报错 printme ( ) 以上实例输出结果： 
 关键字参数 
 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： 实例(Python 3.0+) #!/usr/bin/python3 #可写函数说明 def  printme (  str  ) " 打印任何传入的字符串 " print  ( str ) return #调用printme函数 printme (  str = " 菜鸟教程 " ) 以下实例中演示了函数参数的使用不需要使用指定顺序： 实例(Python 3.0+) #!/usr/bin/python3 #可写函数说明 def  printinfo (  name , age  ) " 打印任何传入的字符串 " print  ( " 名字: " , name ) print  ( " 年龄: " , age ) return #调用printinfo函数 printinfo (  age = 50 , name = " runoob "  ) 以上实例输出结果： 
 默认参数 
 调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： 实例(Python 3.0+) #!/usr/bin/python3 #可写函数说明 def  printinfo (  name , age = 35  ) " 打印任何传入的字符串 " print  ( " 名字: " , name ) print  ( " 年龄: " , age ) return #调用printinfo函数 printinfo (  age = 50 , name = " runoob "  ) print  ( " ------------------------ " ) printinfo (  name = " runoob "  ) 以上实例输出结果： 
 不定长参数 
 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 实例(Python 3.0+) #!/usr/bin/python3 # 可写函数说明 def  printinfo (  arg1 , * vartuple  ) " 打印任何传入的参数 " print  ( " 输出: " ) print  ( arg1 ) print  ( vartuple ) # 调用printinfo 函数 printinfo (  70 , 60 , 50  ) 以上实例输出结果： 实例(Python 3.0+) #!/usr/bin/python3 # 可写函数说明 def  printinfo (  arg1 , * vartuple  ) " 打印任何传入的参数 " print  ( " 输出: " ) print  ( arg1 ) for  var  in  vartuple print  ( var ) return # 调用printinfo 函数 printinfo (  10  ) printinfo (  70 , 60 , 50  ) 以上实例输出结果： ** 基本语法如下： 加了两个星号 ** 的参数会以字典的形式导入。 实例(Python 3.0+) #!/usr/bin/python3 # 可写函数说明 def  printinfo (  arg1 , ** vardict  ) " 打印任何传入的参数 " print  ( " 输出: " ) print  ( arg1 ) print  ( vardict ) # 调用printinfo 函数 printinfo ( 1 , a = 2 , b = 3 ) 以上实例输出结果： 声明函数时，参数中星号 * 可以单独出现，例如: 如果单独出现星号 * 后的参数必须用关键字传入。 
 匿名函数 
 python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 
 语法 
 lambda 函数的语法只包含一个语句，如下： 如下实例： 实例(Python 3.0+) #!/usr/bin/python3 # 可写函数说明 sum = lambda  arg1 , arg2 : arg1 + arg2 # 调用sum函数 print  ( " 相加后的值为 : " , sum (  10 , 20  ) ) print  ( " 相加后的值为 : " , sum (  20 , 20  ) ) 以上实例输出结果： 
 return语句 
 return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法： 实例(Python 3.0+) #!/usr/bin/python3 # 可写函数说明 def  sum (  arg1 , arg2  ) # 返回2个参数的和." total = arg1 + arg2 print  ( " 函数内 : " , total ) return  total # 调用sum函数 total = sum (  10 , 20  ) print  ( " 函数外 : " , total ) 以上实例输出结果： 
 强制位置参数 
 Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。 以下使用方法是正确的: f(10, 20, 30, d=40, e=50, f=60) 以下使用方法会发生错误: 课后练习
	Python3 循环语句

 Python3 循环语句 
 Python 中的循环语句有 for 和 while。 Python 循环语句的控制结构图如下所示： Python 中 while 语句的一般形式： 执行流程图如下： 执行 Gif 演示： 以下实例使用了 while 来计算 1 到 100 的总和： 
 实例 
 #!/usr/bin/env python3 n = 100 sum = 0 counter = 1 while  counter <= n sum = sum + counter counter += 1 print ( " 1 到 %d 之和为: %d " % ( n , sum ) ) 执行结果如下： 
 无限循环 
 我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下： 
 实例 
 #!/usr/bin/python3 var = 1 while  var == 1 : # 表达式永远为 true num = int ( input ( " 输入一个数字  : " ) ) print  ( " 你输入的数字是: " , num ) print  ( " Good bye! " ) 执行以上脚本，输出结果如下： 你可以使用 CTRL+C 来退出当前的无限循环。 无限循环在服务器上客户端的实时请求非常有用。 
 while 循环使用 else 语句 
 语法格式如下： 循环输出数字，并判断大小： 
 实例 
 #!/usr/bin/python3 count = 0 while  count < 5 print  ( count , " 小于 5 " ) count = count + 1 else print  ( count , " 大于或等于 5 " ) 执行以上脚本，输出结果如下： 
 实例 
 #!/usr/bin/python flag = 1 while  ( flag ) : print  ( ' 欢迎访问菜鸟教程! ' ) print  ( " Good bye! " ) 注意： 以上的无限循环你可以使用 CTRL+C 来中断循环。 执行以上脚本，输出结果如下： 
 for 语句 
 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。 for循环的一般格式如下： for < variable > in < sequence statements else statements > 流程图： Python for 循环实例： 
 实例 
 >>> languages = [ " C " , " C++ " , " Perl " , " Python " ] for  x  in  languages print  ( x ) C C Perl Python 以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体： 
 实例 
 #!/usr/bin/python3 sites = [ " Baidu " , " Google " , " Runoob " , " Taobao " ] for  site  in  sites if  site == " Runoob " print ( " 菜鸟教程! " ) break print ( " 循环数据 " + site ) else print ( " 没有循环数据! " ) print ( " 完成循环! " ) 执行脚本后，在循环到 "Runoob"时会跳出循环体： 
 实例 
 >>> for  i  in  range ( 5 ) print ( i ) 0 1 2 3 4 你也可以使用range指定区间的值： 
 实例 
 >>> for  i  in  range ( 5 , 9 ) print ( i ) 5 6 7 8 
 实例 
 >>> for  i  in  range ( 0 , 10 , 3 ) print ( i ) 0 3 6 9 负数： 
 实例 
 >>> for  i  in  range ( - 10 , - 100 , - 30 ) print ( i ) 10 40 70 您可以结合range()和len()函数以遍历一个序列的索引,如下所示: 
 实例 
 >>> a = [ ' Google ' , ' Baidu ' , ' Runoob ' , ' Taobao ' , ' QQ ' ] for  i  in  range ( len ( a ) ) print ( i , a [ i ] ) 0  Google 1  Baidu 2  Runoob 3  Taobao 4  QQ 还可以使用range()函数来创建一个列表： 
 实例 
 >>> list ( range ( 5 ) ) [ 0 , 1 , 2 , 3 , 4 ] break 执行流程图： continue 执行流程图： 代码执行过程： break continue 
 实例 
 
 实例 
  =  5 while n >  0 : =  1 if n ==  2 : break print ( n ) print ( '循环结束。' ) 输出结果为： while 中使用 continue： 
 实例 
  =  5 while n >  0 : =  1 if n ==  2 : continue print ( n ) print ( '循环结束。' ) 输出结果为： 更多实例如下： 
 实例 
 #!/usr/bin/python3 for  letter  in  ' Runoob ' : # 第一个实例 if  letter == ' b ' break print  ( ' 当前字母为 : ' , letter ) var = 10  # 第二个实例 while  var > 0 print  ( ' 当期变量值为 : ' , var ) var = var - 1 if  var == 5 break print  ( " Good bye! " ) 执行以上脚本输出结果为： 
 实例 
 #!/usr/bin/python3 for  letter  in  ' Runoob ' : # 第一个实例 if  letter == ' o ' : # 字母为 o 时跳过输出 continue print  ( ' 当前字母 : ' , letter ) var = 10  # 第二个实例 while  var > 0 var = var - 1 if  var == 5 : # 变量为 5 时跳过输出 continue print  ( ' 当前变量值 : ' , var ) print  ( " Good bye! " ) 执行以上脚本输出结果为： 
 实例 
 #!/usr/bin/python3 for  n  in  range ( 2 , 10 ) for  x  in  range ( 2 , n ) if  n % x == 0 print ( n , ' 等于 ' , x , ' * ' , n // x ) break else # 循环中没有找到元素 print ( n , ' 是质数 ' ) 执行以上脚本输出结果为： 
 pass 语句 
 Python pass是空语句，是为了保持程序结构的完整性。 pass 不做任何事情，一般用做占位语句，如下实例 
 实例 
 >>> while  True pass  # 等待键盘中断 (Ctrl+C) 最小的类: 
 实例 
 >>> class  MyEmptyClass pass 以下实例在字母为 o 时 执行 pass 语句块: 
 实例 
 #!/usr/bin/python3 for  letter  in  ' Runoob ' if  letter == ' o ' pass print  ( ' 执行 pass 块 ' ) print  ( ' 当前字母 : ' , letter ) print  ( " Good bye! " ) 执行以上脚本输出结果为： 课后练习
	Python3 条件控制

 Python3 条件控制 
 Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。   代码执行过程： 
 if 语句 
 Python中if语句的一般形式如下所示： if  condition_1 statement_block_1 elif  condition_2 statement_block_2 else statement_block_3 如果 "condition_1" 为 True 将执行 "statement_block_1" 块语句 如果 "condition_1" 为False，将判断 "condition_2" 如果 "condition_2" 为False，将执行"statement_block_3"块语句 elif 代替了 else if ，所以if语句的关键字为： if – elif – else 注意： : ，表示接下来是满足条件后要执行的语句块。 Gif 演示： 
 实例 
 以下是一个简单的 if 实例： 
 实例 
 #!/usr/bin/python3 var1 = 100 if  var1 print  ( " 1 - if 表达式条件为 true " ) print  ( var1 ) var2 = 0 if  var2 print  ( " 2 - if 表达式条件为 true " ) print  ( var2 ) print  ( " Good bye! " ) 执行以上代码，输出结果为： 从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。 以下实例演示了狗的年龄计算判断： 
 实例 
 #!/usr/bin/python3 age = int ( input ( " 请输入你家狗狗的年龄: " ) ) print ( " " ) if  age <= 0 print ( " 你是在逗我吧! " ) elif  age == 1 print ( " 相当于 14 岁的人。 " ) elif  age == 2 print ( " 相当于 22 岁的人。 " ) elif  age > 2 human = 22 + ( age - 2 ) * 5 print ( " 对应人类年龄: " , human ) ### 退出提示 input ( " 点击 enter 键退出 " ) 将以上脚本保存在dog.py文件中，并执行该脚本： 操作符 描述 < 小于 <= 小于或等于 > 大于 >= 大于或等于 == 等于，比较两个值是否相等 != 不等于 
 实例 
 #!/usr/bin/python3 # 程序演示了 == 操作符 # 使用数字 print ( 5 == 6 ) # 使用变量 x = 5 y = 8 print ( x == y ) high_low.py文件演示了数字的比较运算： 
 实例 
 #!/usr/bin/python3 # 该实例演示了数字猜谜游戏 number = 7 guess = - 1 print ( " 数字猜谜游戏! " ) while  guess != number guess = int ( input ( " 请输入你猜的数字： " ) ) if  guess == number print ( " 恭喜，你猜对了！ " ) elif  guess < number print ( " 猜的数字小了... " ) elif  guess > number print ( " 猜的数字大了... " ) 
 if 嵌套 
 
 实例 
 # !/usr/bin/python3 num = int ( input ( " 输入一个数字： " ) ) if  num % 2 == 0 if  num % 3 == 0 print  ( " 你输入的数字可以整除 2 和 3 " ) else print  ( " 你输入的数字可以整除 2，但不能整除 3 " ) else if  num % 3 == 0 print  ( " 你输入的数字可以整除 3，但不能整除 2 " ) else print  ( " 你输入的数字不能整除 2 和 3 " ) 将以上程序保存到 test_if.py  文件中，执行后输出结果为：
	Python3 编程第一步

 Python3 编程第一步 
 在前面的教程中我们已经学习了一些 Python3 的基本语法知识，下面我们尝试来写一个斐波纳契数列。 实例(Python 3.0+) #!/usr/bin/python3 # Fibonacci series: 斐波纳契数列 # 两个元素的总和确定了下一个数 a , b = 0 , 1 while  b < 10 print ( b ) a , b = b , a + b 其中代码 a, b = b, a+b 的计算方式为先计算右边表达式，然后同时赋值给左边，等价于： 执行以上程序，输出结果为： 第一行包含了一个复合赋值：变量 a 和 b 同时得到新值 0 和 1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。 输出变量值: 
 end 关键字 
 实例(Python 3.0+) #!/usr/bin/python3 # Fibonacci series: 斐波纳契数列 # 两个元素的总和确定了下一个数 a , b = 0 , 1 while  b < 1000 print ( b , end = ' , ' ) a , b = b , a + b 执行以上程序，输出结果为：
	Python3 集合

集合（set）是一个无序的不重复元素序列。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { } ，因为 { } 实例(Python 3.0+) >>> basket = { ' apple ' , ' orange ' , ' apple ' , ' pear ' , ' orange ' , ' banana ' print ( basket )  # 这里演示的是去重功能 ' orange ' , ' banana ' , ' pear ' , ' apple ' ' orange '  in  basket  # 快速判断元素是否在集合内 True ' crabgrass '  in  basket False # 下面展示两个集合间的运算. a = set ( ' abracadabra ' ) b = set ( ' alacazam ' ) a ' a ' , ' r ' , ' b ' , ' c ' , ' d ' a - b  # 集合a中包含而集合b中不包含的元素 ' r ' , ' d ' , ' b ' a | b  # 集合a或b中包含的所有元素 ' a ' , ' c ' , ' r ' , ' d ' , ' b ' , ' m ' , ' z ' , ' l ' a & b  # 集合a和b中都包含了的元素 ' a ' , ' c ' a ^ b  # 不同时包含于a和b的元素 ' r ' , ' d ' , ' b ' , ' m ' , ' z ' , ' l ' } 类似列表推导式，同样集合支持集合推导式(Set comprehension): 实例(Python 3.0+) >>> a = { x  for  x  in  ' abracadabra '  if  x  not  in  ' abc ' a ' r ' , ' d ' } 
 集合的基本操作 
 
 1、添加元素 
 语法格式如下： 实例(Python 3.0+) >>> thisset = set ( ( " Google " , " Runoob " , " Taobao " ) ) thisset . add ( " Facebook " ) print ( thisset ) ' Taobao ' , ' Facebook ' , ' Google ' , ' Runoob ' } 还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下： x 可以有多个，用逗号分开。 实例(Python 3.0+) >>> thisset = set ( ( " Google " , " Runoob " , " Taobao " ) ) thisset . update ( { 1 , 3 } ) print ( thisset ) 1 , 3 , ' Google ' , ' Taobao ' , ' Runoob ' thisset . update ( [ 1 , 4 ] , [ 5 , 6 ] ) print ( thisset ) 1 , 3 , 4 , 5 , 6 , ' Google ' , ' Taobao ' , ' Runoob ' 
 2、移除元素 
 语法格式如下： 实例(Python 3.0+) >>> thisset = set ( ( " Google " , " Runoob " , " Taobao " ) ) thisset . remove ( " Taobao " ) print ( thisset ) ' Google ' , ' Runoob ' thisset . remove ( " Facebook " )  # 不存在会发生错误 Traceback  ( most  recent  call  last ) File  " <stdin> " , line  1 , in < module KeyError : ' Facebook ' 此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示： s.discard( x ) 实例(Python 3.0+) >>> thisset = set ( ( " Google " , " Runoob " , " Taobao " ) ) thisset . discard ( " Facebook " )  # 不存在不会发生错误 print ( thisset ) ' Taobao ' , ' Google ' , ' Runoob ' } 我们也可以设置随机删除集合中的一个元素，语法格式如下： 脚本模式实例(Python 3.0+) thisset = set ( ( " Google " , " Runoob " , " Taobao " , " Facebook " ) ) x = thisset . pop ( ) print ( x ) 输出结果： 多次执行测试结果都不一样。 set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。 
 3、计算集合元素个数 
 语法格式如下： len(s) 计算集合 s 元素个数。 实例(Python 3.0+) >>> thisset = set ( ( " Google " , " Runoob " , " Taobao " ) ) len ( thisset ) 3 
 4、清空集合 
 语法格式如下： 清空集合 s。 实例(Python 3.0+) >>> thisset = set ( ( " Google " , " Runoob " , " Taobao " ) ) thisset . clear ( ) print ( thisset ) set ( ) 
 5、判断元素是否在集合中存在 
 语法格式如下： 判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False。 实例(Python 3.0+) >>> thisset = set ( ( " Google " , " Runoob " , " Taobao " ) ) " Runoob "  in  thisset True " Facebook "  in  thisset False 
 集合内置方法完整列表 
 方法 描述 add() 为集合添加元素 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在。 discard() 删除集合中指定的元素 intersection() 返回集合的交集 intersection_update() isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() 判断指定集合是否为该方法参数集合的子集。 issuperset() 判断该方法的参数集合是否为指定集合的子集 pop() 随机移除元素 remove() 移除指定元素 symmetric_difference() 返回两个集合中不重复的元素集合。 symmetric_difference_update() union() 返回两个集合的并集 update() 给集合添加元素
	Python3 元组
Python3 元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改。 元组使用小括号，列表使用方括号。 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 实例(Python 3.0+) >>> tup1 = ( ' Google ' , ' Runoob ' , 1997 , 2000 ) tup2 = ( 1 , 2 , 3 , 4 , 5  ) tup3 = " a " , " b " , " c " , " d "  #  不需要括号也可以 type ( tup3 ) class  ' tuple ' > 创建空元组 元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用： 实例(Python 3.0+) >>> tup1 = ( 50 ) type ( tup1 )  # 不加逗号，类型为整型 class  ' int ' tup1 = ( 50 , ) type ( tup1 )  # 加上逗号，类型为元组 class  ' tuple ' > 元组与字符串类似，下标索引从0开始，可以进行截取，组合等。 
 访问元组 
 元组可以使用下标索引来访问元组中的值，如下实例: 实例(Python 3.0+) #!/usr/bin/python3 tup1 = ( ' Google ' , ' Runoob ' , 1997 , 2000 ) tup2 = ( 1 , 2 , 3 , 4 , 5 , 6 , 7  ) print  ( " tup1[0]: " , tup1 [ 0 ] ) print  ( " tup2[1:5]: " , tup2 [ 1 : 5 ] ) 以上实例输出结果： 
 修改元组 
 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例: 实例(Python 3.0+) #!/usr/bin/python3 tup1 = ( 12 , 34.56 ) tup2 = ( ' abc ' , ' xyz ' ) # 以下修改元组元素操作是非法的。 # tup1[0] = 100 # 创建一个新的元组 tup3 = tup1 + tup2 print  ( tup3 ) 以上实例输出结果： 
 删除元组 
 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例: 实例(Python 3.0+) #!/usr/bin/python3 tup = ( ' Google ' , ' Runoob ' , 1997 , 2000 ) print  ( tup ) del  tup print  ( " 删除后的元组 tup : " ) print  ( tup ) 以上实例元组被删除后，输出变量会有异常信息，输出如下所示： 
 元组运算符 
 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 ('Hi!', 'Hi!', 'Hi!', 'Hi!') 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print (x,) 1 2 3 迭代 
 元组索引，截取 
 因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示： 元组： Python 表达式 结果 描述 L[2] 'Runoob' 读取第三个元素 L[-2] 'Taobao' 反向读取，读取倒数第二个元素 L[1:] ('Taobao', 'Runoob') 截取元素，从第二个开始后的所有元素。 运行实例如下： 
 元组内置函数 
 Python元组包含了以下内置函数 序号 方法及描述 实例 1 len(tuple) 计算元组元素个数。 2 max(tuple) 返回元组中元素最大值。 3 min(tuple) 返回元组中元素最小值。 4 tuple(iterable) 将可迭代系列转换为元组。 
 关于元组是不可变的 
 所谓元组的不可变指的是元组所指向的内存中的内容不可变。  >>> tup =  ( 'r' ,  'u' ,  'n' ,  'o' ,  'o' ,  'b' ) >>> tup [ 0 ]  =  'g'  # 不支持修改元素 ( most recent call last ) : "<stdin>" , line 1 ,  in  < module > TypeError : 'tuple'  object does not support item assignment >>>  id ( tup )  # 查看内存地址 4440687904 >>> tup =  ( 1 , 2 , 3 ) >>>  id ( tup ) 4441088800  # 内存地址不一样了
	Python3 列表
Python3 列表 序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。 Python有6个序列的内置类型，但最常见的是列表和元组。 序列都可以进行的操作包括索引，切片，加，乘，检查成员。 此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。 列表的数据项不需要具有相同的类型 创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示： list1 = [ ' Google ' , ' Runoob ' , 1997 , 2000 ] list2 = [ 1 , 2 , 3 , 4 , 5  ] list3 = [ " a " , " b " , " c " , " d " ] 与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。 
 访问列表中的值 
 使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示： 实例(Python 3.0+) #!/usr/bin/python3 list1 = [ ' Google ' , ' Runoob ' , 1997 , 2000 ] list2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7  ] print  ( " list1[0]: " , list1 [ 0 ] ) print  ( " list2[1:5]: " , list2 [ 1 : 5 ] ) 运行实例 » 以上实例输出结果： 
 更新列表 
 实例(Python 3.0+) #!/usr/bin/python3 list = [ ' Google ' , ' Runoob ' , 1997 , 2000 ] print  ( " 第三个元素为 : " , list [ 2 ] ) list [ 2 ] = 2001 print  ( " 更新后的第三个元素为 : " , list [ 2 ] ) 注意： 我们会在接下来的章节讨论append()方法的使用 以上实例输出结果： 
 删除列表元素 
 可以使用 del 语句来删除列表的的元素，如下实例： 实例(Python 3.0+) #!/usr/bin/python3 list = [ ' Google ' , ' Runoob ' , 1997 , 2000 ] print  ( " 原始列表 : " , list ) del  list [ 2 ] print  ( " 删除第三个元素 : " , list ) 以上实例输出结果： 注意： 我们会在接下来的章节讨论 remove() 方法的使用 
 Python列表脚本操作符 
 列表对 + 和  * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。 如下所示： Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 ['Hi!'] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print(x, end=" ") 1 2 3 迭代 
 Python列表截取与拼接 
 Python的列表截取与字符串操作类型，如下所示： L = [ ' Google ' , ' Runoob ' , ' Taobao ' ] 操作： Python 表达式 结果 描述 L[2] 'Taobao' 读取第三个元素 L[-2] 'Runoob' 从右侧开始读取倒数第二个元素: count from the right L[1:] ['Runoob', 'Taobao'] 输出从第二个元素开始后的所有元素 >>> L = [ ' Google ' , ' Runoob ' , ' Taobao ' ] L [ 2 ] ' Taobao ' L [ - 2 ] ' Runoob ' L [ 1 : ] [ ' Runoob ' , ' Taobao ' ] 列表还支持拼接操作： >>> squares = [ 1 , 4 , 9 , 16 , 25 ] squares += [ 36 , 49 , 64 , 81 , 100 ] squares [ 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 , 100 ] 
 嵌套列表 
 使用嵌套列表即在列表里创建其它列表，例如： >>> a = [ ' a ' , ' b ' , ' c ' ] n = [ 1 , 2 , 3 ] x = [ a , n ] x [ [ ' a ' , ' b ' , ' c ' ] , [ 1 , 2 , 3 ] ] x [ 0 ] [ ' a ' , ' b ' , ' c ' ] x [ 0 ] [ 1 ] ' b ' 
 Python列表函数&方法 
 Python包含以下函数: 序号 函数 1 len(list) 列表元素个数 2 max(list) 返回列表元素最大值 3 min(list) 返回列表元素最小值 4 list(seq) 将元组转换为列表 Python包含以下方法: 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 对原列表进行排序 10 list.clear() 清空列表 11 list.copy() 复制列表
	Python3 模块

 Python3 模块 
 在前面的几个章节中我们脚本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。 为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。 实例(Python 3.0+) #!/usr/bin/python3 # 文件名: using_sys.py import  sys print ( ' 命令行参数如下: ' ) for  i  in  sys . argv print ( i ) print ( ' \n \n Python 路径为： ' , sys . path , ' \n ' ) 执行结果如下所示： 1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。 
 import 语句 
 想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下： 搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端： support.py 文件代码 #!/usr/bin/python3 # Filename: support.py def  print_func (  par  ) print  ( " Hello : " , par ) return test.py 引入 support 模块： test.py 文件代码 #!/usr/bin/python3 # Filename: test.py # 导入模块 import  support # 现在可以调用模块里包含的函数了 support . print_func ( " Runoob " ) 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。 当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？ 实例 # 斐波那契(fibonacci)数列模块 def  fib ( n ) : # 定义到 n 的斐波那契数列 a , b = 0 , 1 while  b < n print ( b , end = '  ' ) a , b = b , a + b print ( ) def  fib2 ( n ) : # 返回到 n 的斐波那契数列 result = [ ] a , b = 0 , 1 while  b < n result . append ( b ) a , b = b , a + b return  result 然后进入Python解释器，使用下面的命令导入这个模块： 实例 >>> fibo . fib ( 1000 ) 1  1  2  3  5  8  13  21  34  55  89  144  233  377  610  987 fibo . fib2 ( 100 ) [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] fibo . __name__ ' fibo ' 如果你打算经常使用一个函数，你可以把它赋给一个本地的名称： Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下： 例如，要导入模块 fibo 的 fib 函数，使用如下语句： 这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。 
 from … import * 语句 
 
 深入模块 
 模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。 还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如: 
 __name__属性 
 说明： __name__ 与 __main__ 底下是双下划线， _ _ 是这样去掉中间的那个空格。 
 dir() 函数 
 如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称: 有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。 这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。 
 包 
 不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个"包"）。 现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。 :exc:ImportError import item.subitem.subsubitem Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。 在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。 作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/__init__.py中包含如下代码: __all__ 真的没有定义，那么使用 from sound.effects import * 这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。 * 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。 from Package import specific_submodule 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。
	Python3 字符串
Python3 字符串 字符串是 Python 中最常用的数据类型。我们可以使用引号( ' 或 " )来创建字符串。 创建字符串很简单，只要为变量分配一个值即可。例如： var1 = ' Hello World! ' var2 = " Runoob " 
 Python 访问字符串中的值 
 Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。 Python 访问子字符串，可以使用方括号来截取字符串，如下实例： 实例(Python 3.0+) #!/usr/bin/python3 var1 = ' Hello World! ' var2 = " Runoob " print  ( " var1[0]: " , var1 [ 0 ] ) print  ( " var2[1:5]: " , var2 [ 1 : 5 ] ) 以上实例执行结果： 
 Python 字符串更新 
 你可以截取字符串的一部分并与其他字段拼接，如下实例： 实例(Python 3.0+) #!/usr/bin/python3 var1 = ' Hello World! ' print  ( " 已更新字符串 : " , var1 [ : 6 ] + ' Runoob! ' ) 以上实例执行结果 
 Python转义字符 
 在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。如下表： 转义字符 描述 \(在行尾时) 续行符 \\ 反斜杠符号 \' 单引号 \" 双引号 \a 响铃 \b 退格(Backspace) \000 空 \n 换行 \v 纵向制表符 \t 横向制表符 \r 回车 \f 换页 \oyy 八进制数， yy 代表的字符，例如： \o12 代表换行，其中 o 是字母，不是数字 0。 \xyy 十六进制数，yy代表的字符，例如：\x0a代表换行 \other 其它的字符以普通格式输出 
 Python字符串运算符 
 下表实例变量a值为字符串 "Hello"，b变量值为 "Python"： 操作符 描述 实例 + 字符串连接 a + b 输出结果： HelloPython * 重复输出字符串 a*2 输出结果：HelloHello [] 通过索引获取字符串中字符 a[1] 输出结果 e [ : ] 截取字符串中的一部分，遵循 左闭右开 原则，str[0:2] 是不包含第 3 个字符的。 a[1:4] 输出结果 ell in 成员运算符 - 如果字符串中包含给定的字符返回 True  'H' in a 输出结果 True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True  'M' not in a 输出结果 True r/R r （可以大小写）以外，与普通字符串有着几乎完全相同的语法。 % 格式字符串 请看下一节内容。 实例(Python 3.0+) #!/usr/bin/python3 a = " Hello " b = " Python " print ( " a + b 输出结果： " , a + b ) print ( " a * 2 输出结果： " , a * 2 ) print ( " a[1] 输出结果： " , a [ 1 ] ) print ( " a[1:4] 输出结果： " , a [ 1 : 4 ] ) if (  " H "  in  a ) print ( " H 在变量 a 中 " ) else print ( " H 不在变量 a 中 " ) if (  " M "  not  in  a ) print ( " M 不在变量 a 中 " ) else print ( " M 在变量 a 中 " ) print  ( r ' \n ' ) print  ( R ' \n ' ) 以上实例输出结果为： 
 Python字符串格式化 
 Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。 在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。 实例(Python 3.0+) #!/usr/bin/python3 print  ( " 我叫 %s 今年 %d 岁! " % ( ' 小明 ' , 10 ) ) 以上实例输出结果： python字符串格式化符号: 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) <sp> 在正数前面显示空格 # 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X') 0 显示的数字前面填充'0'而不是默认的空格 % '%%'输出一个单一的'%' (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) Python2.6 开始，新增了一种格式化字符串的函数 str.format() ，它增强了字符串格式化的功能。 
 Python三引号 
 python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下 实例(Python 3.0+) #!/usr/bin/python3 para_str = """ \t \n """ print  ( para_str ) 以上实例执行结果为： 三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。 一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。 errHTML = ''' ''' cursor . execute ( ''' ''' ) 
 f-string 
 f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。 之前我们习惯用百分号 (%): 实例  >>> name =  'Runoob' >>>  'Hello %s' % name 'Hello Runoob'  f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下： 实例  >>> name =  'Runoob' >>> f 'Hello {name}'  # 替换变量 >>> f '{1+2}'  # 使用表达式 '3' >>> w =  { 'name' : 'Runoob' ,  'url' : 'www.runoob.com' } >>> f '{w["name"]}: {w["url"]}' 'Runoob: www.runoob.com' 用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。 在 Python 3.8 的版本中可以使用 = 符号来拼接运算表达式与结果： 实例  >>> x =  1 >>>  print ( f '{x+1}' )  # Python 3.6 2 >>> x =  1 >>>  print ( f '{x+1=}' )  # Python 3.8 'x+1=2' 
 Unicode 字符串 
 u 
 Python 的字符串内建函数 
 Python 的字符串常用内建函数如下： 序号 方法及描述 1 capitalize() 将字符串的第一个字符转换为大写 2 center(width, fillchar) 3 count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 4 bytes.decode(encoding="utf-8", errors="strict") Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 5 encode(encoding='UTF-8',errors='strict') 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' 6 endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. 7 expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 8 find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 9 index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. 10 isalnum() 11 isalpha() 12 isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. 13 islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False 14 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False 15 isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. 16 istitle() 17 isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False 18 join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 19 len(string) 返回字符串长度 20 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 21 lower() 转换字符串中所有大写字符为小写. 22 lstrip() 截掉字符串左边的空格或指定字符。 23 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 24 max(str) 返回字符串 str 中最大的字母。 25 min(str) 返回字符串 str 中最小的字母。 26 replace(old, new [, max]) 把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 27 rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. 28 rindex( str, beg=0, end=len(string)) 类似于 index()，不过是从右边开始. 29 rjust(width,[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 30 rstrip() 删除字符串字符串末尾的空格. 31 split(str="", num=string.count(str)) 32 splitlines([keepends]) 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 33 startswith(substr, beg=0,end=len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 34 strip([chars]) 在字符串上执行 lstrip()和 rstrip() 35 swapcase() 将字符串中大写转换为小写，小写转换为大写 36 title() 返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) 37 translate(table, deletechars="") 38 upper() 39 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 40 isdecimal()
	Python3 数字(Number)

 Python3 数字(Number) 
 Python 数字数据类型用于存储数值。 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。 以下实例在变量赋值时 Number 对象将被创建： 您也可以使用del语句删除一些数字对象的引用。 del语句的语法是： 您可以通过使用del语句删除单个或多个对象的引用，例如： Python 支持三种不同的数值类型： 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 10 2 = 250） 复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 我们可以使用十六进制和八进制来代表整数： int float complex 10 0.0 3.14j 100 15.20 45.j -786 -21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6545+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j 
 Python 数字类型转换 
 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 int(x) 将x转换为一个整数。 float(x) 将x转换到一个浮点数。  complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 以下实例将浮点数变量 a 转换为整数： 
 Python 数字运算 
 Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。 表达式的语法很直白： + , - , * 和 / , 和其它语言（如Pascal或C）里一样。例如： 注意： 在不同的机器上浮点运算的结果可能会不一样。 在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 // ： 注意： // 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。 = Python 可以使用 ** 操作来进行幂运算： 变量在使用前必须先"定义"（即赋予变量一个值），否则会出现错误： 不同类型的数混合运算时会将整数转换为浮点数： _ 此处， _ 
 数学函数 
 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1。 Python 3 已废弃，使用 (x>y)-(x<y) 替换 。 exp(x) 返回e的x次幂(e x ),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。 其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) 返回数字x的平方根。 
 随机数函数 
 随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 Python包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 
 三角函数 
 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(x*x + y*y)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ，  返回90.0 radians(x) 将角度转换为弧度 
 数学常量 
 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数）。
	Python3  字典
Python3 字典 字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值(key=>value)对用冒号( : )分割，每个对之间用逗号( , )分割，整个字典包括在花括号( {}) 键必须是唯一的，但值则不必。 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 一个简单的字典实例： 也可如此创建字典： 
 访问字典里的值 
 把相应的键放入到方括号中，如下实例: 实例 #!/usr/bin/python3 dict = { ' Name ' : ' Runoob ' , ' Age ' : 7 , ' Class ' : ' First ' print  ( " dict['Name']: " , dict [ ' Name ' ] ) print  ( " dict['Age']: " , dict [ ' Age ' ] ) 以上实例输出结果： 如果用字典里没有的键访问数据，会输出错误如下： 实例 #!/usr/bin/python3 dict = { ' Name ' : ' Runoob ' , ' Age ' : 7 , ' Class ' : ' First ' print  ( " dict['Alice']: " , dict [ ' Alice ' ] ) 以上实例输出结果： 
 修改字典 
 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 实例 #!/usr/bin/python3 dict = { ' Name ' : ' Runoob ' , ' Age ' : 7 , ' Class ' : ' First ' dict [ ' Age ' ] = 8  # 更新 Age dict [ ' School ' ] = " 菜鸟教程 "  # 添加信息 print  ( " dict['Age']: " , dict [ ' Age ' ] ) print  ( " dict['School']: " , dict [ ' School ' ] ) 
 删除字典元素 
 能删单一的元素也能清空字典，清空只需一项操作。 显示删除一个字典用del命令，如下实例： 实例 #!/usr/bin/python3 dict = { ' Name ' : ' Runoob ' , ' Age ' : 7 , ' Class ' : ' First ' del  dict [ ' Name ' ]  # 删除键 'Name' dict . clear ( )  # 清空字典 del  dict  # 删除字典 print  ( " dict['Age']: " , dict [ ' Age ' ] ) print  ( " dict['School']: " , dict [ ' School ' ] ) 但这会引发一个异常，因为用执行 del 操作后字典不再存在： 注： del() 方法后面也会讨论。 
 字典键的特性 
 字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。 两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例： 实例 #!/usr/bin/python3 dict = { ' Name ' : ' Runoob ' , ' Age ' : 7 , ' Name ' : ' 小菜鸟 ' print  ( " dict['Name']: " , dict [ ' Name ' ] ) 以上实例输出结果： 2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例： 实例 #!/usr/bin/python3 dict = { [ ' Name ' ] : ' Runoob ' , ' Age ' : 7 print  ( " dict['Name']: " , dict [ ' Name ' ] ) 以上实例输出结果： 
 字典内置函数&方法 
 Python字典包含了以下内置函数： 序号 函数及描述 实例 1 len(dict) 计算字典元素个数，即键的总数。 2 str(dict) 输出字典，以可打印的字符串表示。 3 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 Python字典包含了以下内置方法： 序号 函数及描述 1 radiansdict.clear() 删除字典内所有元素 2 radiansdict.copy() 返回一个字典的浅复制 3 radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 4 radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5 key in dict 如果键在字典dict里返回true，否则返回false 6 radiansdict.items() 以列表返回可遍历的(键, 值) 元组数组 7 radiansdict.keys() 返回一个迭代器，可以使用 list() 来转换为列表 8 radiansdict.setdefault(key, default=None) 9 radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里 10 radiansdict.values() 返回一个迭代器，可以使用 list() 来转换为列表 11 pop(key[,default]) 12 popitem() 随机返回并删除字典中的最后一对键和值。 课后练习
	Python3 注释

 Python3 注释 
 确保对模块, 函数, 方法和行内注释使用正确的风格 Python中的注释有单行注释和多行注释： Python中单行注释以 # 开头，例如：：  # 这是一个注释 print ( " Hello, World! " ) 多行注释用三个单引号 ''' 或者三个双引号 """ 将注释括起来，例如: 
 1、单引号（'''） 
  #!/usr/bin/python3 ''' ''' print ( " Hello, World! " ) 
 2、双引号（"""） 
  #!/usr/bin/python3 """ """ print ( " Hello, World! " )
	Python3 解释器

 Python3 解释器 
 /usr/local/python3 安装完成后，我们可以将路径 /usr/local/python3/bin 在Window系统下你可以通过以下命令来设置Python的环境变量，假设你的Python安装在 C:\Python34 下: 我们可以在命令提示符中输入"Python"命令来启动Python解释器： 执行以上命令后，出现如下窗口信息： 在 python 提示符中输入以下语句，然后按回车键查看运行效果： 以上命令执行结果如下： 当键入一个多行结构时，续行是必须的。我们可以看下如下 if 语句： 将如下代码拷贝至 hello.py 文件中： 通过以下命令执行该脚本： 输出结果为： 然后修改脚本权限，使其有执行权限，命令如下： 执行以下命令： 输出结果为：
	Python3 基本数据类型

 Python3 基本数据类型 
 在 Python 中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。 等号（=）用来给变量赋值。 实例(Python 3.0+) #!/usr/bin/python3 =  100  # 整型变量 =  1000.0  # 浮点型变量 =  "runoob"  # 字符串 print  ( counter ) print  ( miles ) print  ( name ) 运行实例 » 执行以上程序会输出如下结果： 
 多个变量赋值 
 
 标准数据类型 
 
 Number（数字） 
 
 String（字符串） 
 
 List（列表） 
 
 Tuple（元组） 
 
 Set（集合） 
 
 Dictionary（字典） 
 Python3 的六个标准数据类型中： 不可变数据（3 个）： Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）： 
 Number（数字） 
 Python3 支持 int、float、bool、complex（复数） 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 像大多数语言一样，数值类型的赋值和计算都是很直观的。 内置的 type() 函数可以用来查询变量所指的对象类型。 此外还可以用 isinstance 来判断： 实例 >>> a =  111 >>>  isinstance ( a ,  int ) True >>>  注意： 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。 当你指定一个值时，Number 对象就会被创建： 您可以通过使用del语句删除单个或多个对象。例如： 
 数值运算 
 实例 >>>  5 + 4  # 加法 9 >>>  4.3 - 2  # 减法 2.3 >>>  3 * 7  # 乘法 21 >>>  2 / 4  # 除法，得到一个浮点数 0.5 >>>  2 // 4  # 除法，得到一个整数 0 >>>  17 % 3  # 取余 2 >>>  2 ** 5  # 乘方 32 注意： 1、Python可以同时为多个变量赋值，如a, b = 1, 2。 / 返回一个浮点数， // 返回一个整数。 
 数值类型实例 
 int float complex 10 0.0 3.14j 100 15.20 45.j -786 -21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6545+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 
 String（字符串） 
 Python中的字符串用单引号 ' 或双引号 " 括起来，同时使用反斜杠 \ 转义特殊字符。 字符串的截取的语法格式如下：  变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。 加号 + 是字符串的连接符， 星号 * 表示复制当前字符串，与之结合的数字为复制的次数。实例如下： 实例 #!/usr/bin/python3 str  =  'Runoob' print  ( str )  # 输出字符串 print  ( str [ 0 :- 1 ] )  # 输出第一个到倒数第二个的所有字符 print  ( str [ 0 ] )  # 输出字符串第一个字符 print  ( str [ 2 : 5 ] )  # 输出从第三个开始到第五个的字符 print  ( str [ 2 : ] )  # 输出从第三个开始的后的所有字符 print  ( str * 2 )  # 输出字符串两次，也可以写成 print (2 * str) print  ( str + "TEST" )  # 连接字符串 执行以上程序会输出如下结果： Python 使用反斜杠 \ 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r ，表示原始字符串： """...""" 或者 '''...''' 实例 >>> word =  'Python' >>>  print ( word [ 0 ] , word [ 5 ] ) >>>  print ( word [ - 1 ] , word [ - 6 ] ) 注意： 
 List（列表） 
 List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 列表截取的语法格式如下：  变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。 加号 + 是列表连接运算符，星号 * 实例 #!/usr/bin/python3 list  =  [  'abcd' ,  786  ,  2.23 ,  'runoob' ,  70.2  ] =  [ 123 ,  'runoob' ] print  ( list )  # 输出完整列表 print  ( list [ 0 ] )  # 输出列表第一个元素 print  ( list [ 1 : 3 ] )  # 从第二个开始输出到第三个元素 print  ( list [ 2 : ] )  # 输出从第三个元素开始的所有元素 print  ( tinylist * 2 )  # 输出两次列表 print  ( list + tinylist )  # 连接列表 以上实例输出结果： 与Python字符串不一样的是，列表中的元素是可以改变的： 实例 >>> a =  [ 1 ,  2 ,  3 ,  4 ,  5 ,  6 ] >>> a [ 0 ]  =  9 >>> a [ 2 : 5 ]  =  [ 13 ,  14 ,  15 ] >>> a [ 9 ,  2 ,  13 ,  14 ,  15 ,  6 ] >>> a [ 2 : 5 ]  =  [ ]  # 将对应的元素值设置为 [] >>> a [ 9 ,  2 ,  6 ] List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。 注意： Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串： 实例  def reverseWords ( input ) : # 通过空格将字符串分隔符，把各个单词分隔为列表 =  input . split ( " " )  # 翻转字符串 # 假设列表 list = [1,2,3,4], # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) # inputWords[-1::-1] 有三个参数 # 第一个参数 -1 表示最后一个元素 # 第二个参数为空，表示移动到列表末尾 # 第三个参数为步长，-1 表示逆向 = inputWords [ - 1 ::- 1 ]  # 重新组合字符串 =  ' ' . join ( inputWords )  return output if __name__ ==  "__main__" : input  =  'I like runoob' = reverseWords ( input )  print ( rw ) 输出结果为： runoob like I 
 Tuple（元组） 
 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 实例 #!/usr/bin/python3 tuple  =  (  'abcd' ,  786  ,  2.23 ,  'runoob' ,  70.2  ) =  ( 123 ,  'runoob' ) print  ( tuple )  # 输出完整元组 print  ( tuple [ 0 ] )  # 输出元组的第一个元素 print  ( tuple [ 1 : 3 ] )  # 输出从第二个元素开始到第三个元素 print  ( tuple [ 2 : ] )  # 输出从第三个元素开始的所有元素 print  ( tinytuple * 2 )  # 输出两次元组 print  ( tuple + tinytuple )  # 连接元组 以上实例输出结果： 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。 实例 >>> tup =  ( 1 ,  2 ,  3 ,  4 ,  5 ,  6 ) >>>  print ( tup [ 0 ] ) 1 >>>  print ( tup [ 1 : 5 ] ) ( 2 ,  3 ,  4 ,  5 ) >>> tup [ 0 ]  =  11  # 修改元组元素的操作是非法的 ( most recent call last ) : "<stdin>" , line 1 ,  in  < module > TypeError : 'tuple'  object does not support item assignment >>>  string、list 和 tuple 都属于 sequence（序列）。 注意： 
 Set（集合） 
 基本功能是进行成员关系测试和删除重复元素。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { } ，因为 { } 创建格式： 实例 #!/usr/bin/python3 =  { 'Google' ,  'Taobao' ,  'Runoob' ,  'Facebook' ,  'Zhihu' ,  'Baidu' } print ( sites )  # 输出集合，重复的元素被自动去掉 # 成员测试 if  'Runoob'  in sites : print ( 'Runoob 在集合中' ) else : print ( 'Runoob 不在集合中' ) # set可以进行集合运算 =  set ( 'abracadabra' ) =  set ( 'alacazam' ) print ( a ) print ( a - b )  # a 和 b 的差集 print ( a | b )  # a 和 b 的并集 print ( a & b )  # a 和 b 的交集 print ( a ^ b )  # a 和 b 中不同时存在的元素 以上实例输出结果： 
 Dictionary（字典） 
 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。 键(key)必须使用不可变类型。 实例 #!/usr/bin/python3 dict  =  { } dict [ 'one' ]  =  "1 - 菜鸟教程" dict [ 2 ]  =  "2 - 菜鸟工具" =  { 'name' : 'runoob' , 'code' : 1 ,  'site' : 'www.runoob.com' } print  ( dict [ 'one' ] )  # 输出键为 'one' 的值 print  ( dict [ 2 ] )  # 输出键为 2 的值 print  ( tinydict )  # 输出完整的字典 print  ( tinydict. keys ( ) )  # 输出所有键 print  ( tinydict. values ( ) )  # 输出所有值 以上实例输出结果： 构造函数 dict() 可以直接从键值对序列中构建字典如下： 实例 >>>  dict ( [ ( 'Runoob' ,  1 ) ,  ( 'Google' ,  2 ) ,  ( 'Taobao' ,  3 ) ] ) { 'Runoob' : 1 ,  'Google' : 2 ,  'Taobao' : 3 } >>>  { x: x** 2  for x in  ( 2 ,  4 ,  6 ) } { 2 : 4 ,  4 : 16 ,  6 : 36 } >>>  dict ( Runoob = 1 , Google = 2 , Taobao = 3 ) { 'Runoob' : 1 ,  'Google' : 2 ,  'Taobao' : 3 } >>>  另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。 注意： { } 。 
 Python数据类型转换 
 函数 描述 int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串
	Python3 基础语法

编码 UTF-8 上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。 
 标识符 
 第一个字符必须是字母表中字母或下划线 _ 。 标识符的其他的部分由字母、数字和下划线组成。 标识符对大小写敏感。 
 python保留字 
 
 注释 
 # 实例(Python 3.0+) #!/usr/bin/python3 # 第一个注释 print  ( " Hello, Python! " )  # 第二个注释 执行以上代码，输出结果为： 多行注释可以用多个 # 号，还有 ''' 和 """ ： 实例(Python 3.0+) #!/usr/bin/python3 # 第一个注释 # 第二个注释 ''' ''' """ """ print  ( " Hello, Python! " ) 执行以上代码，输出结果为： {} 。 实例(Python 3.0+) if  True print  ( " True " ) else print  ( " False " ) 以下代码最后一行语句缩进数的空格数不一致，会导致运行错误： 以上程序由于缩进不一致，执行后会出现类似以下错误： 
 多行语句 
 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠(\)来实现多行语句，例如： 在  [], {}, 或 () 中的多行语句，不需要使用反斜杠(\)，例如： 
 数字(Number)类型 
 python中数字有四种类型：整数、布尔型、浮点数和复数。 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 bool (布尔), 如 True。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 
 字符串(String) 
 python中单引号和双引号使用完全相同。 使用三引号('''或""")可以指定一个多行字符串。 转义符 '\' 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r"this is a line with \n" 则\n会显示，并不是换行。 按字面意义级联字符串，如"this " "is " "string"会被自动转换为this is string。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下： 变量[头下标:尾下标:步长] 实例(Python 3.0+) #!/usr/bin/python3 str = ' Runoob ' print ( str )  # 输出字符串 print ( str [ 0 :- 1 ] )  # 输出第一个到倒数第二个的所有字符 print ( str [ 0 ] )  # 输出字符串第一个字符 print ( str [ 2 : 5 ] )  # 输出从第三个开始到第五个的字符 print ( str [ 2 : ] )  # 输出从第三个开始后的所有字符 print ( str * 2 )  # 输出字符串两次 print ( str + ' 你好 ' )  # 连接字符串 print ( ' ------------------------------ ' ) print ( ' hello \n runoob ' )  # 使用反斜杠(\)+n转义特殊字符 print ( r ' hello \n runoob ' )  # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 这里的 r 指 raw，即 raw string。 输出结果为： 
 空行 
 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住： 空行也是程序代码的一部分。 
 等待用户输入 
 执行下面的程序在按回车键后就会等待用户输入： 实例(Python 3.0+) #!/usr/bin/python3 input ( " \n \n 按下 enter 键后退出。 " ) 以上代码中 ，"\n\n"在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。 
 同一行显示多条语句 
 实例(Python 3.0+) #!/usr/bin/python3 import  sys ; x = ' runoob ' ; sys . stdout . write ( x + ' \n ' ) 使用脚本执行以上代码，输出结果为： 使用交互式命令行执行，输出结果为： 此处的 7 表示字符数。 
 多个语句构成代码组 
 缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 如下实例： 
 Print 输出 
 print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end="" ： 实例(Python 3.0+) #!/usr/bin/python3 x = " a " y = " b " # 换行输出 print (  x  ) print (  y  ) print ( ' --------- ' ) # 不换行输出 print (  x , end = "  "  ) print (  y , end = "  "  ) print ( ) 以上实例执行结果为： 
 import 与 from...import 
 在 python 用 import 或者 from...import 来导入相应的模块。 import somemodule from somemodule import somefunction from somemodule import firstfunc, secondfunc, thirdfunc from somemodule import * 导入 sys 模块 import  sys print ( ' ================Python import mode========================== ' ) print  ( ' 命令行参数为: ' ) for  i  in  sys . argv print  ( i ) print  ( ' \n python 路径为 ' , sys . path ) 导入 sys 模块的 argv,path 成员 from  sys  import  argv , path  #  导入特定的成员 print ( ' ================python from import=================================== ' ) print ( ' path: ' , path )  # 因为已经导入path成员，所以此处引用时不需要加sys.path 
 命令行参数 
 很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息： 我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数，具体使用可以参照 Python 3 命令行参数 。
	Python3 环境搭建
Python3 环境搭建 本章节我们将向大家介绍如何在本地搭建 Python3 开发环境。 Python3 可应用于多平台包括 Windows、Linux 和 Mac OS X。 Unix (Solaris, Linux, FreeBSD, AIX, HP/UX, SunOS, IRIX, 等等。) Win 9x/NT/2000 Macintosh (Intel, PPC, 68K) OS/2 DOS (多个DOS版本) PalmOS Nokia 移动手机 Windows CE Acorn/RISC OS BeOS Amiga VMS/OpenVMS QNX VxWorks Psion Python 同样可以移植到 Java 和 .NET 虚拟机上。 
 Python3 下载 
 Python3 最新源码，二进制文档，新闻资讯等可以在 Python 的官网查看到： Python 官网： https://www.python.org/ 你可以在以下链接中下载 Python 的文档，你可以下载 HTML、PDF 和 PostScript 等格式的文档。 Python文档下载地址： https://www.python.org/doc/ 
 Python 安装 
 Python 已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。 您需要下载适用于您使用平台的二进制代码，然后安装 Python。 如果您平台的二进制代码是不可用的，你需要使用C编译器手动编译源代码。 编译的源代码，功能上有更多的选择性， 为 Python 安装提供了更多的灵活性。 以下是各个平台安装包的下载地址： Source Code 可用于 Linux 上的安装。 以下为不同平台上安装 Python3 的方法。 
 Unix & Linux 平台安装 Python3: 
 以下为在 Unix & Linux 平台上安装 Python 的简单步骤： 打开WEB浏览器访问 https://www.python.org/downloads/source/ 选择适用于 Unix/Linux 的源码压缩包。 下载及解压压缩包 Python-3.x.x.tgz ， 3.x.x 为你下载的对应版本号。 如果你需要自定义一些选项修改 Modules/Setup  以 Python3.6.1 版本为例： 检查 Python3 是否正常可用： 
 Window 平台安装 Python: 
 以下为在 Window 平台上安装 Python 的简单步骤。 打开 WEB 浏览器访问 https://www.python.org/downloads/windows/ ，一般就下载 executable installer，x86 表示是 32 位机子的，x86-64 表示 64 位机子的。 记得勾选 Add Python 3.6 to PATH 。 按 Win+R 键，输入 cmd 调出命令提示符，输入 python: 也可以在开始菜单中搜索 IDLE ： 
 MAC 平台安装 Python: 
 MAC 系统都自带有 Python2.7 环境，你可以在链接 https://www.python.org/downloads/mac-osx/ 上下载最新版安装 Python 3.x。 你也可以参考源码安装的方式来安装。 
 环境变量配置 
 程序和可执行文件可以在许多目录，而这些路径很可能不在操作系统提供可执行文件的搜索路径中。 path(路径)存储在环境变量中，这是由操作系统维护的一个命名的字符串。这些变量包含可用的命令行解释器和其他程序的信息。 Unix或Windows中路径变量为PATH（UNIX区分大小写，Windows不区分大小写）。 在Mac OS中，安装程序过程中改变了python的安装路径。如果你需要在其他目录引用Python，你必须在path中添加Python目录。 
 在 Unix/Linux 设置环境变量 
 在 csh shell: 输入 setenv PATH "$PATH:/usr/local/bin/python" , 按下 Enter 。 在 bash shell (Linux) 输入 : export PATH="$PATH:/usr/local/bin/python" 按下 Enter 。 在 sh 或者 ksh shell 输入:  PATH="$PATH:/usr/local/bin/python" 按下 Enter。 注意: /usr/local/bin/python 是 Python 的安装目录。 
 在 Windows 设置环境变量 
 在环境变量中添加Python目录： 在命令提示框中(cmd) : 输入 path=%path%;C:\Python 注意: C:\Python 是Python的安装目录。 也可以通过以下方式设置： 右键点击"计算机"，然后点击"属性" 然后点击"高级系统设置" ps：记住，路径直接用分号"；"隔开！ 
 Python 环境变量 
 下面几个重要的环境变量，它应用于Python： 变量名 描述 PYTHONPATH PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。 PYTHONSTARTUP Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。 PYTHONCASEOK 加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写. PYTHONHOME 另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。 
 运行Python 
 有三种方式可以运行Python： 
 1、交互式解释器： 
 你可以通过命令行窗口进入python并开在交互式解释器中开始编写Python代码。 你可以在Unix，DOS或任何其他提供了命令行或者shell的系统进行python编码工作。 以下为Python命令行参数： 选项 描述 -d 在解析时显示调试信息 -O 生成优化代码 ( .pyo 文件 ) -S 启动时不引入查找Python路径的位置 -V 输出Python版本号 -X -c cmd 执行 Python 脚本，并将运行结果作为 cmd 字符串。 file 在给定的python文件执行python脚本。 
 2、命令行脚本 
 在你的应用程序中通过引入解释器可以在命令行中执行Python脚本，如下所示： 注意： 在执行脚本时，请检查脚本是否有可执行权限。 
 3、集成开发环境（IDE：Integrated Development Environment）: PyCharm 
 PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。 PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制…… PyCharm 下载地址 : https://www.jetbrains.com/pycharm/download/ PyCharm 安装地址： http://www.runoob.com/w3cnote/pycharm-windows-install.html
	Python3 简介
Python3 简介 Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。 Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 >>> 后直接执行代码。 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 Python 是初学者的语言： Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 
 Python 发展历史 
 Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。 Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。 像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。 现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。 Python 2.0 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。 Python 3.0 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的Python 2.6/2.7版本。 Python 3.0 版本，常被称为 Python 3000，或简称 Py3k。相对于 Python 的早期版本，这是一个较大的升级。 Python 2.7 被确定为最后一个 Python 2.x 版本，它除了支持 Python 2.x 语法外，还支持部分 Python 3.1 语法。 
 Python 特点 
 1.易于学习： Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。 2.易于阅读： Python代码定义的更清晰。 3.易于维护： Python的成功在于它的源代码是相当容易维护的。 4.一个广泛的标准库： Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。 5.互动模式： 互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。 6.可移植： 基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。 7.可扩展： 如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。 8.数据库： Python提供所有主要的商业数据库的接口。 9.GUI编程： Python支持GUI可以创建和移植到许多系统调用。 10.可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得"脚本化"的能力。 
 Python 应用 
 ...
	Python3 运算符
Python3 运算符 
 什么是运算符？ 
 本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 4 和 5 被称为 操作数 ，" + " 称为运算符。 Python语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 接下来让我们一个个来学习Python的运算符。 
 Python算术运算符 
 以下假设变量a为10，变量b为21： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 31 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 - x 除以 y b / a 输出结果 2.1 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回x的y次幂 a**b 为10的21次方 // 取整除 - 向下取接近商的整数 以下实例演示了Python所有算术运算符的操作： 实例(Python 3.0+) #!/usr/bin/python3 a = 21 b = 10 c = 0 c = a + b print  ( " 1 - c 的值为： " , c ) c = a - b print  ( " 2 - c 的值为： " , c ) c = a * b print  ( " 3 - c 的值为： " , c ) c = a / b print  ( " 4 - c 的值为： " , c ) c = a % b print  ( " 5 - c 的值为： " , c ) # 修改变量 a 、b 、c a = 2 b = 3 c = a ** b print  ( " 6 - c 的值为： " , c ) a = 10 b = 5 c = a // b print  ( " 7 - c 的值为： " , c ) 以上实例输出结果： 
 Python比较运算符 
 以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。 > 大于 - 返回x是否大于y (a > b) 返回 False。 < 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a < b) 返回 True。 >= 大于等于 - 返回x是否大于等于y。 (a >= b) 返回 False。 <= 小于等于 - 返回x是否小于等于y。 (a <= b) 返回 True。 以下实例演示了Python所有比较运算符的操作： 实例(Python 3.0+) #!/usr/bin/python3 a = 21 b = 10 c = 0 if  (  a == b  ) print  ( " 1 - a 等于 b " ) else print  ( " 1 - a 不等于 b " ) if  (  a != b  ) print  ( " 2 - a 不等于 b " ) else print  ( " 2 - a 等于 b " ) if  (  a < b  ) print  ( " 3 - a 小于 b " ) else print  ( " 3 - a 大于等于 b " ) if  (  a > b  ) print  ( " 4 - a 大于 b " ) else print  ( " 4 - a 小于等于 b " ) # 修改变量 a 和 b 的值 a = 5 b = 20 if  (  a <= b  ) print  ( " 5 - a 小于等于 b " ) else print  ( " 5 - a 大于  b " ) if  (  b >= a  ) print  ( " 6 - b 大于等于 a " ) else print  ( " 6 - b 小于 a " ) 以上实例输出结果： 
 Python赋值运算符 
 以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a := 海象运算符，可在表达式内部为变量赋值。 Python3.8 版本新增运算符 。 在这个示例中，赋值表达式可以避免调用 len() 两次: 以下实例演示了Python所有赋值运算符的操作： 实例(Python 3.0+) #!/usr/bin/python3 a = 21 b = 10 c = 0 c = a + b print  ( " 1 - c 的值为： " , c ) c += a print  ( " 2 - c 的值为： " , c ) c *= a print  ( " 3 - c 的值为： " , c ) c /= a print  ( " 4 - c 的值为： " , c ) c = 2 c %= a print  ( " 5 - c 的值为： " , c ) c **= a print  ( " 6 - c 的值为： " , c ) c //= a print  ( " 7 - c 的值为： " , c ) 以上实例输出结果： 
 Python位运算符 
 下表中变量 a 为 60，b 为 13二进制格式如下： 运算符 描述 实例 & 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a & b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。 ~x 类似于 -x-1  (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 << 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 a << 2 输出结果 240 ，二进制解释： 1111 0000 >> 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 a >> 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了Python所有位运算符的操作： 实例(Python 3.0+) #!/usr/bin/python3 a = 60  # 60 = 0011 1100 b = 13  # 13 = 0000 1101 c = 0 c = a & b ; # 12 = 0000 1100 print  ( " 1 - c 的值为： " , c ) c = a | b ; # 61 = 0011 1101 print  ( " 2 - c 的值为： " , c ) c = a ^ b ; # 49 = 0011 0001 print  ( " 3 - c 的值为： " , c ) c = ~ a ; # -61 = 1100 0011 print  ( " 4 - c 的值为： " , c ) c = a << 2 ; # 240 = 1111 0000 print  ( " 5 - c 的值为： " , c ) c = a >> 2 ; # 15 = 0000 1111 print  ( " 6 - c 的值为： " , c ) 以上实例输出结果： 
 Python逻辑运算符 
 Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： 实例(Python 3.0+) #!/usr/bin/python3 a = 10 b = 20 if  (  a  and  b  ) print  ( " 1 - 变量 a 和 b 都为 true " ) else print  ( " 1 - 变量 a 和 b 有一个不为 true " ) if  (  a  or  b  ) print  ( " 2 - 变量 a 和 b 都为 true，或其中一个变量为 true " ) else print  ( " 2 - 变量 a 和 b 都不为 true " ) # 修改变量 a 的值 a = 0 if  (  a  and  b  ) print  ( " 3 - 变量 a 和 b 都为 true " ) else print  ( " 3 - 变量 a 和 b 有一个不为 true " ) if  (  a  or  b  ) print  ( " 4 - 变量 a 和 b 都为 true，或其中一个变量为 true " ) else print  ( " 4 - 变量 a 和 b 都不为 true " ) if  not (  a  and  b  ) print  ( " 5 - 变量 a 和 b 都为 false，或其中一个变量为 false " ) else print  ( " 5 - 变量 a 和 b 都为 true " ) 以上实例输出结果： 
 Python成员运算符 
 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了Python所有成员运算符的操作： 实例(Python 3.0+) #!/usr/bin/python3 a = 10 b = 20 list = [ 1 , 2 , 3 , 4 , 5  ] if  (  a  in  list  ) print  ( " 1 - 变量 a 在给定的列表中 list 中 " ) else print  ( " 1 - 变量 a 不在给定的列表中 list 中 " ) if  (  b  not  in  list  ) print  ( " 2 - 变量 b 不在给定的列表中 list 中 " ) else print  ( " 2 - 变量 b 在给定的列表中 list 中 " ) # 修改变量 a 的值 a = 2 if  (  a  in  list  ) print  ( " 3 - 变量 a 在给定的列表中 list 中 " ) else print  ( " 3 - 变量 a 不在给定的列表中 list 中 " ) 以上实例输出结果： 
 Python身份运算符 
 运算符 描述 实例 is  x is y , 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b) 。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注：  id() 函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作： 实例(Python 3.0+) #!/usr/bin/python3 a = 20 b = 20 if  (  a  is  b  ) print  ( " 1 - a 和 b 有相同的标识 " ) else print  ( " 1 - a 和 b 没有相同的标识 " ) if  (  id ( a ) == id ( b )  ) print  ( " 2 - a 和 b 有相同的标识 " ) else print  ( " 2 - a 和 b 没有相同的标识 " ) # 修改变量 b 的值 b = 30 if  (  a  is  b  ) print  ( " 3 - a 和 b 有相同的标识 " ) else print  ( " 3 - a 和 b 没有相同的标识 " ) if  (  a  is  not  b  ) print  ( " 4 - a 和 b 没有相同的标识 " ) else print  ( " 4 - a 和 b 有相同的标识 " ) 以上实例输出结果： is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 >>> a = [ 1 , 2 , 3 ] b = a b  is  a True b == a True b = a [ : ] b  is  a False b == a True 
 Python运算符优先级 
 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，求余数和取整除 + - 加法减法 >> << 右移，左移运算符 & 位 'AND' ^ | 位运算符 <= < > >= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 以下实例演示了Python所有运算符优先级的操作： 实例(Python 3.0+) #!/usr/bin/python3 a = 20 b = 10 c = 15 d = 5 e = 0 e = ( a + b ) * c / d  #( 30 * 15 ) / 5 print  ( " (a + b) * c / d 运算结果为： " , e ) e = ( ( a + b ) * c ) / d  # (30 * 15 ) / 5 print  ( " ((a + b) * c) / d 运算结果为： " , e ) e = ( a + b ) * ( c / d ) ; # (30) * (15/5) print  ( " (a + b) * (c / d) 运算结果为： " , e ) e = a + ( b * c ) / d ; #  20 + (150/5) print  ( " a + (b * c) / d 运算结果为： " , e ) 以上实例输出结果： and 拥有更高优先级: 实例  x = True y = False z = False if  x  or  y  and  z print ( " yes " ) else print ( " no " ) 以上实例输出结果： 注意： 课后练习
	Python3 正则表达式

 Python3 正则表达式 
 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 本章节主要介绍 Python 中常用的正则表达式处理函数，如果你对正则表达式不了解，可以查看我们的 正则表达式 - 教程 。 
 re.match函数 
 re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法 ： 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见： 
 正则表达式修饰符 - 可选标志 
 匹配成功re.match方法返回一个匹配的对象，否则返回None。 我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 
 实例 
 #!/usr/bin/python import  re print ( re . match ( ' www ' , ' www.runoob.com ' ) . span ( ) )  # 在起始位置匹配 print ( re . match ( ' com ' , ' www.runoob.com ' ) )  # 不在起始位置匹配 以上实例运行输出结果为： 
 实例 
 #!/usr/bin/python3 import  re line = " Cats are smarter than dogs " # .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符 matchObj = re . match (  r ' (.*) are (.*?) .* ' , line , re . M | re . I ) if  matchObj print  ( " matchObj.group() : " , matchObj . group ( ) ) print  ( " matchObj.group(1) : " , matchObj . group ( 1 ) ) print  ( " matchObj.group(2) : " , matchObj . group ( 2 ) ) else print  ( " No match!! " ) 以上实例执行结果如下： 
 re.search方法 
 re.search 扫描整个字符串并返回第一个成功的匹配。 函数语法： 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见： 
 正则表达式修饰符 - 可选标志 
 匹配成功re.search方法返回一个匹配的对象，否则返回None。 我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 
 实例 
 #!/usr/bin/python3 import  re print ( re . search ( ' www ' , ' www.runoob.com ' ) . span ( ) )  # 在起始位置匹配 print ( re . search ( ' com ' , ' www.runoob.com ' ) . span ( ) )  # 不在起始位置匹配 以上实例运行输出结果为： 实例 #!/usr/bin/python3 import  re line = " Cats are smarter than dogs " searchObj = re . search (  r ' (.*) are (.*?) .* ' , line , re . M | re . I ) if  searchObj print  ( " searchObj.group() : " , searchObj . group ( ) ) print  ( " searchObj.group(1) : " , searchObj . group ( 1 ) ) print  ( " searchObj.group(2) : " , searchObj . group ( 2 ) ) else print  ( " Nothing found!! " ) 
 re.match与re.search的区别 
 re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。 实例 #!/usr/bin/python3 import  re line = " Cats are smarter than dogs " matchObj = re . match (  r ' dogs ' , line , re . M | re . I ) if  matchObj print  ( " match --> matchObj.group() : " , matchObj . group ( ) ) else print  ( " No match!! " ) matchObj = re . search (  r ' dogs ' , line , re . M | re . I ) if  matchObj print  ( " search --> matchObj.group() : " , matchObj . group ( ) ) else print  ( " No match!! " ) 
 检索和替换 
 Python 的re模块提供了re.sub用于替换字符串中的匹配项。 语法： 参数： pattern : 正则中的模式字符串。 flags : 编译时用的匹配模式，数字形式。 前三个为必选参数，后两个为可选参数。 实例 #!/usr/bin/python3 import  re phone = " 2004-959-559 # 这是一个电话号码 " # 删除注释 num = re . sub ( r ' #.*$ ' , " " , phone ) print  ( " 电话号码 : " , num ) # 移除非数字的内容 num = re . sub ( r ' \D ' , " " , phone ) print  ( " 电话号码 : " , num ) 以上实例执行结果如下： 
 repl 参数是一个函数 
 实例 #!/usr/bin/python import  re # 将匹配的数字乘于 2 def  double ( matched ) value = int ( matched . group ( ' value ' ) ) return  str ( value * 2 ) s = ' A23G4HFD567 ' print ( re . sub ( ' (?P<value> \d +) ' , double , s ) ) A46G8HFD1134 
 compile 函数 
 compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 参数： 
 实例 
 
 实例 
 >>> import  re pattern = re . compile ( r ' \d + ' )  # 用于匹配至少一个数字 m = pattern . match ( ' one12twothree34four ' )  # 查找头部，没有匹配 print (  m  ) None m = pattern . match ( ' one12twothree34four ' , 2 , 10 )  # 从'e'的位置开始匹配，没有匹配 print (  m  ) None m = pattern . match ( ' one12twothree34four ' , 3 , 10 )  # 从'1'的位置开始匹配，正好匹配 print (  m  )  # 返回一个 Match 对象 _sre . SRE_Match  object  at  0 x10a42aac0 m . group ( 0 )  # 可省略 0 ' 12 ' m . start ( 0 )  # 可省略 0 3 m . end ( 0 )  # 可省略 0 5 m . span ( 0 )  # 可省略 0 ( 3 , 5 ) 在上面，当匹配成功时返回一个 Match 对象，其中： group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0) ； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group)) 。 再看看一个例子： 
 实例 
 >>> import  re pattern = re . compile ( r ' ([a-z]+) ([a-z]+) ' , re . I )  # re.I 表示忽略大小写 m = pattern . match ( ' Hello World Wide Web ' ) print (  m  )  # 匹配成功，返回一个 Match 对象 _sre . SRE_Match  object  at  0 x10bea83e8 m . group ( 0 )  # 返回匹配成功的整个子串 ' Hello World ' m . span ( 0 )  # 返回匹配成功的整个子串的索引 ( 0 , 11 ) m . group ( 1 )  # 返回第一个分组匹配成功的子串 ' Hello ' m . span ( 1 )  # 返回第一个分组匹配成功的子串的索引 ( 0 , 5 ) m . group ( 2 )  # 返回第二个分组匹配成功的子串 ' World ' m . span ( 2 )  # 返回第二个分组匹配成功的子串索引 ( 6 , 11 ) m . groups ( )  # 等价于 (m.group(1), m.group(2), ...) ( ' Hello ' , ' World ' ) m . group ( 3 )  # 不存在第三个分组 Traceback  ( most  recent  call  last ) File  " <stdin> " , line  1 , in < module IndexError : no  such  group 
 findall 
 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search  是匹配一次 findall 匹配所有。 语法格式为： re.findall(string[, pos[, endpos]]) 参数： string pos endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 查找字符串中的所有数字： 
 实例 
 import  re pattern = re . compile ( r ' \d + ' )  # 查找数字 result1 = pattern . 
 findall 
 ( ' runoob 123 google 456 ' ) result2 = pattern . 
 findall 
 ( ' run88oob123google456 ' , 0 , 10 ) print ( result1 ) print ( result2 ) 输出结果： 
 re.finditer 
 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见： 
 正则表达式修饰符 - 可选标志 
 
 实例 
 import  re it = re . finditer ( r " \d + " , " 12a32bc43jf3 " ) for  match  in  it print  ( match . group ( )  ) 输出结果： 
 re.split 
 split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见： 
 正则表达式修饰符 - 可选标志 
 
 实例 
 >>> import  re re . split ( ' \W + ' , ' runoob, runoob, runoob. ' ) [ ' runoob ' , ' runoob ' , ' runoob ' , ' ' ] re . split ( ' ( \W +) ' , ' runoob, runoob, runoob. ' ) [ ' ' , '  ' , ' runoob ' , ' , ' , ' runoob ' , ' , ' , ' runoob ' , ' . ' , ' ' ] re . split ( ' \W + ' , ' runoob, runoob, runoob. ' , 1 ) [ ' ' , ' runoob, runoob, runoob. ' ] re . split ( ' a* ' , ' hello world ' )  # 对于一个找不到匹配的字符串而言，split 不会对其作出分割 [ ' hello world ' ] 
 正则表达式对象 
 re.compile() 返回 RegexObject 对象。 group() 返回被 RE 匹配的字符串。 start() end() span() 
 正则表达式修饰符 - 可选标志 
 正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 
 正则表达式模式 
 模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t' ，等价于 \\t )匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 [...] 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k' [^...] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。例如，"o{2}"不能匹配"Bob"中的"o"，但是能匹配"food"中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，"o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有o。"o{1,}"等价于"o+"。"o{0,}"则等价于"o*"。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (...), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#...) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?> re) 匹配的独立模式，省去回溯。 \w 匹配数字字母下划线 \W 匹配非数字字母下划线 \s 匹配任意空白字符，等价于 [\t\n\r\f]。 \S 匹配任意非空字符 \d 匹配任意数字，等价于 [0-9]。 \D 匹配任意非数字 \A 匹配字符串开始 \Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \z 匹配字符串结束 \G 匹配最后匹配完成的位置。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 \B 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 \n, \t, 等。 匹配一个换行符。匹配一个制表符, 等 \1...\9 匹配第n个分组的内容。 \10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 字符匹配 
 实例 
 描述 python 匹配 "python". 字符类 
 实例 
 描述 [Pp]ython 匹配 "Python" 或 "python" rub[ye] 匹配 "ruby" 或 "rube" [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] [^0-9] 特殊字符类 
 实例 
 描述 . 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。 \W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
	